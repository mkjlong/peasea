{"ast":null,"code":"const PIECES = \"TIJLOSZ\";\n\n//get rid of it\nexport function sortByPCOrder(a, b) {\n  return PIECES.indexOf(a) - PIECES.indexOf(b);\n}\nexport function extractBracketedBlock(input, start) {\n  let depth = 0;\n  let i = start;\n  let block = \"\";\n  for (; i < input.length; i++) {\n    const char = input[i];\n    block += char;\n    if (char === '[') depth++;else if (char === ']') depth--;\n    if (depth === 0) break;\n  }\n  if (depth !== 0) throw new Error(\"Unmatched brackets\");\n  return [block.slice(1, -1), i + 1]; // exclude outer [ ]\n}\n\n//good\nexport function normalizedSort(input) {\n  const counts = {\n    T: 0,\n    I: 0,\n    J: 0,\n    L: 0,\n    O: 0,\n    S: 0,\n    Z: 0\n  };\n  for (const char of input) {\n    if (PIECES.includes(char)) {\n      counts[char]++;\n    }\n  }\n  return Object.entries(counts).sort((_ref, _ref2) => {\n    let [pieceA, countA] = _ref;\n    let [pieceB, countB] = _ref2;\n    return countB - countA || PIECES.indexOf(pieceA) - PIECES.indexOf(pieceB);\n  }) // TIJLOSZ order\n  .flatMap(_ref3 => {\n    let [piece, count] = _ref3;\n    return Array(count).fill(piece);\n  }).join('');\n}\n\n//good\nexport function normalizeInput(input) {\n  // Precompile regex patterns for better performance\n  const invalidSyntaxRegex = /[^TIJLOSZ\\[\\]\\^\\!\\*\\dpc]/g;\n  const inversionRegex = /\\[\\^([A-Z]+)\\]/g;\n  const wildcardRegex = /\\*/g;\n  const bagWithExclamationRegex = /\\[([A-Z]+)\\]!/g;\n  const bagWithNumberRegex = /\\[([A-Z]+)\\](\\d)/g;\n  const bareBagRegex = /\\[([A-Z]+)\\](?![pc]\\d)/g;\n\n  // 1. Remove invalid syntax\n  let cleaned = input.replace(invalidSyntaxRegex, \"\");\n\n  // 2. Inversion: [^TIJ] → [LOSZ]\n  cleaned = cleaned.replace(inversionRegex, (_, negated) => PIECES.split(\"\").filter(c => !negated.includes(c)).join(\"\"));\n\n  // 3. Replace * with [TIJLOSZ]\n  cleaned = cleaned.replace(wildcardRegex, \"[\".concat(PIECES, \"]\"));\n\n  // 4. Replace [XYZ]! → [XYZ]pN\n  cleaned = cleaned.replace(bagWithExclamationRegex, (_, bag) => \"[\".concat(bag, \"]p\").concat(bag.length));\n\n  // 5. Replace [XYZ]N → [XYZ]pN\n  cleaned = cleaned.replace(bagWithNumberRegex, (_, bag, n) => \"[\".concat(bag, \"]p\").concat(n));\n\n  // 6. Replace bare [XYZ] → [XYZ]p1\n  cleaned = cleaned.replace(bareBagRegex, (_, bag) => \"[\".concat(bag, \"]p1\"));\n  return cleaned;\n}\nexport function getPermutations(str, length) {\n  if (typeof str !== \"string\") {\n    const result = new Set();\n    for (const s of str) {\n      for (const perm of getPermutations(s, length)) {\n        result.add(perm);\n      }\n    }\n    return result;\n  }\n  const results = new Set();\n  const chars = normalizedSort(str);\n  function backtrack(path, used) {\n    if (path.length === length) {\n      results.add(path.join(\"\"));\n      return;\n    }\n    for (let i = 0; i < chars.length; i++) {\n      if (used[i]) continue;\n      // Skip duplicates\n      if (i > 0 && chars[i] === chars[i - 1] && !used[i - 1]) continue;\n      used[i] = true;\n      path.push(chars[i]);\n      backtrack(path, used);\n      path.pop();\n      used[i] = false;\n    }\n  }\n  backtrack([], Array(chars.length).fill(false));\n  return results;\n}\nexport function getCombinations(str, length) {\n  if (typeof str !== \"string\") {\n    const result = new Set();\n    for (const s of str) {\n      for (const comb of getCombinations(s, length)) {\n        result.add(comb);\n      }\n    }\n    return result;\n  }\n  const results = new Set();\n  const chars = normalizedSort(str); // Pre-sorted input\n\n  const stack = [{\n    start: 0,\n    path: []\n  }];\n  while (stack.length > 0) {\n    const {\n      start,\n      path\n    } = stack.pop();\n    if (path.length === length) {\n      results.add(path.join(\"\"));\n      continue;\n    }\n    for (let i = start; i < chars.length; i++) {\n      // Skip duplicates\n      if (i > start && chars[i] === chars[i - 1]) continue;\n      stack.push({\n        start: i + 1,\n        path: [...path, chars[i]]\n      });\n    }\n  }\n  return results;\n}\nexport function pieces(input) {\n  input = normalizeInput(input);\n  const parts = [];\n  if (input.split('').every(c => PIECES.includes(c))) {\n    return new Set([input]);\n  }\n  let i = 0;\n  while (i < input.length) {\n    const char = input[i];\n    if (char === '[') {\n      const [bagContent, nextIndex] = extractBracketedBlock(input, i);\n      i = nextIndex;\n      const mode = input[i];\n      i++;\n      let numStr = \"\";\n      while (/\\d/.test(input[i])) {\n        numStr += input[i++];\n      }\n      const num = Number(numStr);\n      const expandedBag = pieces(bagContent);\n      if (mode === \"p\") {\n        parts.push(getPermutations(expandedBag, num));\n      } else if (mode === \"c\") {\n        parts.push(getCombinations(expandedBag, num));\n      }\n    } else if (PIECES.includes(char)) {\n      parts.push(new Set([char]));\n      i++;\n    } else {\n      i++;\n    }\n  }\n  return cartesianProduct(parts);\n}\nfunction cartesianProduct(arrays) {\n  return arrays.reduce((acc, curr) => {\n    const result = new Set();\n    for (const a of acc) {\n      for (const b of curr) {\n        result.add(a + b);\n      }\n    }\n    return result;\n  }, new Set([\"\"]));\n}\nexport function checkPieces(queue, pattern) {\n  //Fix queue (remove unnessesary pieces, replace * with [TIJLOSZ].)\n  pattern = pattern.replaceAll(/\\*/g, \"[TIJLOSZ]\").replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\n\n  //Iterate through each bag and compare to queue\n  for (let [_, set, count = 1] of Array.from(pattern.matchAll(/((?<=\\[)\\^?[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\n    set = set.startsWith(\"^\") ? \"TIJLOSZ\".split(\"\").filter(piece => !set.includes(piece)).join(\"\") : set;\n    count = count === \"!\" ? set.length : Number(count);\n    if (queue.length < count || set.length < count) return false;\n    for (let piece of queue.substring(0, count)) {\n      if (!set.includes(piece)) return false;\n      set = set.replace(piece, \"\");\n    }\n    queue = queue.substring(count, queue.length);\n  }\n  return !queue.length;\n}\nfunction checkModifiers(queue, pattern) {\n  return false;\n}\n\n// export default function pieces(queue: string, pattern: string): boolean {\n//     console.log(`Queue: ${queue}, Set: ${pattern}`);\n//     var [pattern, modifiers] = pattern.split(\"{\");\n//     if (modifiers?.endsWith(\"}\"))\n//         modifiers = modifiers.slice(0, modifiers.length - 1);\n//     console.log(`Pattern: ${pattern}, Modifiers: ${modifiers}`);\n\n//     const queuePieces = queue.trim();\n//     return checkPieces(queuePieces, pattern);\n// }","map":{"version":3,"names":["PIECES","sortByPCOrder","a","b","indexOf","extractBracketedBlock","input","start","depth","i","block","length","char","Error","slice","normalizedSort","counts","T","I","J","L","O","S","Z","includes","Object","entries","sort","_ref","_ref2","pieceA","countA","pieceB","countB","flatMap","_ref3","piece","count","Array","fill","join","normalizeInput","invalidSyntaxRegex","inversionRegex","wildcardRegex","bagWithExclamationRegex","bagWithNumberRegex","bareBagRegex","cleaned","replace","_","negated","split","filter","c","concat","bag","n","getPermutations","str","result","Set","s","perm","add","results","chars","backtrack","path","used","push","pop","getCombinations","comb","stack","pieces","parts","every","bagContent","nextIndex","mode","numStr","test","num","Number","expandedBag","cartesianProduct","arrays","reduce","acc","curr","checkPieces","queue","pattern","replaceAll","set","from","matchAll","startsWith","substring","checkModifiers"],"sources":["C:/Stuff/Github/peasea/frontend/src/scripts/pieces.ts"],"sourcesContent":["const PIECES = \"TIJLOSZ\";\r\n\r\n//get rid of it\r\nexport function sortByPCOrder(a:string,b:string){\r\n    return PIECES.indexOf(a)-PIECES.indexOf(b);\r\n}\r\n\r\nexport function extractBracketedBlock(input: string, start: number): [string, number] {\r\n    let depth = 0;\r\n    let i = start;\r\n    let block = \"\";\r\n\r\n    for (; i < input.length; i++) {\r\n        const char = input[i];\r\n        block += char;\r\n        if (char === '[') depth++;\r\n        else if (char === ']') depth--;\r\n\r\n        if (depth === 0) break;\r\n    }\r\n\r\n    if (depth !== 0) throw new Error(\"Unmatched brackets\");\r\n\r\n    return [block.slice(1, -1), i + 1]; // exclude outer [ ]\r\n}\r\n\r\n//good\r\nexport function normalizedSort(input: string): string {\r\n    const counts: Record<string, number> = {T:0,I:0,J:0,L:0,O:0,S:0,Z:0};\r\n    for (const char of input) {\r\n        if (PIECES.includes(char)) {\r\n            counts[char]++;\r\n        }\r\n    }\r\n    return Object.entries(counts)\r\n        .sort(([pieceA, countA], [pieceB, countB]) => (countB - countA) || PIECES.indexOf(pieceA) - PIECES.indexOf(pieceB)) // TIJLOSZ order\r\n        .flatMap(([piece, count]) => Array(count).fill(piece))\r\n        .join('');\r\n}\r\n\r\n//good\r\nexport function normalizeInput(input: string): string {\r\n    // Precompile regex patterns for better performance\r\n    const invalidSyntaxRegex = /[^TIJLOSZ\\[\\]\\^\\!\\*\\dpc]/g;\r\n    const inversionRegex = /\\[\\^([A-Z]+)\\]/g;\r\n    const wildcardRegex = /\\*/g;\r\n    const bagWithExclamationRegex = /\\[([A-Z]+)\\]!/g;\r\n    const bagWithNumberRegex = /\\[([A-Z]+)\\](\\d)/g;\r\n    const bareBagRegex = /\\[([A-Z]+)\\](?![pc]\\d)/g;\r\n\r\n    // 1. Remove invalid syntax\r\n    let cleaned = input.replace(invalidSyntaxRegex, \"\");\r\n\r\n    // 2. Inversion: [^TIJ] → [LOSZ]\r\n    cleaned = cleaned.replace(inversionRegex, (_, negated) =>\r\n        PIECES.split(\"\").filter(c => !negated.includes(c)).join(\"\")\r\n    );\r\n\r\n    // 3. Replace * with [TIJLOSZ]\r\n    cleaned = cleaned.replace(wildcardRegex, `[${PIECES}]`);\r\n\r\n    // 4. Replace [XYZ]! → [XYZ]pN\r\n    cleaned = cleaned.replace(bagWithExclamationRegex, (_, bag) => `[${bag}]p${bag.length}`);\r\n\r\n    // 5. Replace [XYZ]N → [XYZ]pN\r\n    cleaned = cleaned.replace(bagWithNumberRegex, (_, bag, n) => `[${bag}]p${n}`);\r\n\r\n    // 6. Replace bare [XYZ] → [XYZ]p1\r\n    cleaned = cleaned.replace(bareBagRegex, (_, bag) => `[${bag}]p1`);\r\n\r\n    return cleaned;\r\n}\r\n\r\nexport function getPermutations(str: string | Set<string>, length: number): Set<string> {\r\n    if (typeof str !== \"string\") {\r\n        const result = new Set<string>();\r\n        for (const s of str) {\r\n            for (const perm of getPermutations(s, length)) {\r\n                result.add(perm);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    const results: Set<string> = new Set();\r\n    const chars = normalizedSort(str);\r\n\r\n    function backtrack(path: string[], used: boolean[]) {\r\n        if (path.length === length) {\r\n            results.add(path.join(\"\"));\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < chars.length; i++) {\r\n            if (used[i]) continue;\r\n            // Skip duplicates\r\n            if (i > 0 && chars[i] === chars[i - 1] && !used[i - 1]) continue;\r\n\r\n            used[i] = true;\r\n            path.push(chars[i]);\r\n            backtrack(path, used);\r\n            path.pop();\r\n            used[i] = false;\r\n        }\r\n    }\r\n\r\n    backtrack([], Array(chars.length).fill(false));\r\n    return results;\r\n}\r\n\r\nexport function getCombinations(str: string | Set<string>, length: number): Set<string> {\r\n    if (typeof str !== \"string\") {\r\n        const result = new Set<string>();\r\n        for (const s of str) {\r\n            for (const comb of getCombinations(s, length)) {\r\n                result.add(comb);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    const results: Set<string> = new Set();\r\n    const chars = normalizedSort(str); // Pre-sorted input\r\n\r\n    const stack: { start: number; path: string[] }[] = [{ start: 0, path: [] }];\r\n\r\n    while (stack.length > 0) {\r\n        const { start, path } = stack.pop()!;\r\n\r\n        if (path.length === length) {\r\n            results.add(path.join(\"\"));\r\n            continue;\r\n        }\r\n\r\n        for (let i = start; i < chars.length; i++) {\r\n            // Skip duplicates\r\n            if (i > start && chars[i] === chars[i - 1]) continue;\r\n\r\n            stack.push({ start: i + 1, path: [...path, chars[i]] });\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\nexport function pieces(input: string): Set<string> {\r\n    input = normalizeInput(input);\r\n    const parts: Set<string>[] = [];\r\n\r\n    if (input.split('').every(c => PIECES.includes(c))) {\r\n        return new Set([input]);\r\n    }\r\n\r\n    let i = 0;\r\n    while (i < input.length) {\r\n        const char = input[i];\r\n        if (char === '[') {\r\n            const [bagContent, nextIndex] = extractBracketedBlock(input, i);\r\n            i = nextIndex;\r\n\r\n            const mode = input[i];\r\n            i++;\r\n\r\n            let numStr = \"\";\r\n            while (/\\d/.test(input[i])) {\r\n                numStr += input[i++];\r\n            }\r\n            const num = Number(numStr);\r\n\r\n            const expandedBag = pieces(bagContent);\r\n            if (mode === \"p\") {\r\n                parts.push(getPermutations(expandedBag, num));\r\n            } else if (mode === \"c\") {\r\n                parts.push(getCombinations(expandedBag, num));\r\n            }\r\n        } else if (PIECES.includes(char)) {\r\n            parts.push(new Set([char]));\r\n            i++;\r\n        } else {\r\n            i++;\r\n        }\r\n    }\r\n\r\n    return cartesianProduct(parts);\r\n}\r\n\r\nfunction cartesianProduct(arrays: Set<string>[]): Set<string> {\r\n    return arrays.reduce((acc, curr) => {\r\n        const result: Set<string> = new Set();\r\n        for (const a of acc) {\r\n            for (const b of curr) {\r\n                result.add(a + b);\r\n            }\r\n        }\r\n        return result;\r\n    }, new Set([\"\"]));\r\n}\r\n\r\nexport function checkPieces(queue: string, pattern: string): boolean {\r\n    //Fix queue (remove unnessesary pieces, replace * with [TIJLOSZ].)\r\n    pattern = pattern.replaceAll(/\\*/g, \"[TIJLOSZ]\").replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\r\n\r\n\r\n    //Iterate through each bag and compare to queue\r\n    for (let [_, set, count = 1] of Array.from(pattern.matchAll(/((?<=\\[)\\^?[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\r\n        set = set.startsWith(\"^\") ? \"TIJLOSZ\".split(\"\").filter((piece) => !set.includes(piece)).join(\"\") : set;\r\n        count = count === \"!\" ? set.length : Number(count);\r\n        if(queue.length < count || set.length < count)return false;\r\n\r\n        for (let piece of queue.substring(0, count)) {\r\n            if (!set.includes(piece)) return false;\r\n            set = set.replace(piece, \"\");\r\n        }\r\n        queue = queue.substring(count, queue.length);\r\n    }\r\n\r\n    return !queue.length;\r\n}\r\n\r\nfunction checkModifiers(queue: string, pattern: string): boolean {\r\n    \r\n    \r\n    return false;\r\n}\r\n\r\n// export default function pieces(queue: string, pattern: string): boolean {\r\n//     console.log(`Queue: ${queue}, Set: ${pattern}`);\r\n//     var [pattern, modifiers] = pattern.split(\"{\");\r\n//     if (modifiers?.endsWith(\"}\"))\r\n//         modifiers = modifiers.slice(0, modifiers.length - 1);\r\n//     console.log(`Pattern: ${pattern}, Modifiers: ${modifiers}`);\r\n\r\n//     const queuePieces = queue.trim();\r\n//     return checkPieces(queuePieces, pattern);\r\n// }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}