{"ast":null,"code":"import { PC } from \"./PC\";\nimport { normalizedSort } from \"./pieces\";\nimport { tetrimino, tetriminos } from \"./Tetrimino\";\nexport class PCGroup {\n  constructor(arg) {\n    this.bag = void 0;\n    this.duplicate = void 0;\n    this.code = void 0;\n    if (/^\\d+$/.test(arg.toString()) || typeof arg === \"number\") {\n      if (typeof arg === \"string\" && !/^\\d+$/.test(arg)) {\n        this.code = parseInt(arg, 10);\n      } else {\n        this.code = arg;\n      }\n      // abc = duplicate (bits 9-7), defghij = group (bits 6-0)\n      let dupeBits = this.code >> 7 & 0b111;\n      let bagBits = this.code & 0b1111111;\n      // Special case: both 0000000000 and 1111111000 are \"first PC\"\n      if (this.code === 0 || this.code === 0b1111111000) {\n        this.bag = new Set();\n        this.duplicate = undefined;\n        return;\n      }\n      // Invalid: all 1s with nonzero dupe\n      if (bagBits === 0b1111111 && dupeBits !== 0) bagBits = 0b0000000;\n      // Build group as Set<Tetrimino>\n      let group = new Set();\n      for (let i = 1; i <= 7; ++i) {\n        if (bagBits & 1 << 7 - i) {\n          group.add(tetrimino(i));\n        }\n      }\n      this.bag = group;\n      if (dupeBits > 0) {\n        this.duplicate = tetrimino(dupeBits);\n      }\n    } else if (typeof arg === \"string\") {\n      this.code = PCGroup.encodeQueue(arg);\n      const pcGroup = new PCGroup(this.code);\n      this.bag = pcGroup.bag;\n      this.duplicate = pcGroup.duplicate;\n    } else {\n      throw new Error(\"Invalid constructor arguments\");\n    }\n  }\n  static encodeQueue(str) {\n    let dupe = undefined;\n    let bag = new Set();\n    //get rid of all invalid PCGroup string formats\n    str = str.toUpperCase().replace(/[^JTSLIZO<>\\-\\+]/g, \"\").replace(\"-\", \">\").replace(\"+\", \"<\");\n    if (str.includes(\">\")) {\n      //Format: X>YZ , X is the duplicate piece, YZ is the INVERTED bag.\n      if (str.includes(\"<\")) throw new Error(\"Invalid PCGroup string format\");\n      let [dupeString, bagString] = str.split(\">\");\n      if (dupeString.length > 1 || bagString.length > 7) throw new Error(\"Invalid PCGroup string format\");\n      if (bagString.length === 0) bagString = \"\";\n      dupe = tetrimino(dupeString);\n      bag = new Set(tetriminos).difference(new Set(bagString.split(\"\").map(tetrimino)));\n      if (bag.size !== 7 - bagString.length) throw new Error(\"Invalid PCGroup string format\");\n    } else if (str.includes(\"<\")) {\n      if (str.includes(\">\")) throw new Error(\"Invalid PCGroup string format\");\n      //Format: X<YZ , X is the duplicate piece, YZ is the bag.\n      let [dupeString, bagString] = str.split(\"<\");\n      if (dupeString.length > 1 || bagString.length > 7) throw new Error(\"Invalid PCGroup string format\");\n      dupe = tetrimino(dupeString);\n      bag = new Set(bagString.split(\"\").map(tetrimino));\n      if (bag.size !== bagString.length) throw new Error(\"Invalid PCGroup string format\");\n    } else {\n      //Queue only consists of tetriminos, there can be up to 1 duplicate.\n      if (str.length > 7) throw new Error(\"Invalid PCGroup string format\");\n      dupe = undefined;\n      bag = new Set();\n      for (const t of str.split(\"\").map(tetrimino)) {\n        if (bag.has(t)) {\n          if (dupe) throw new Error(\"Invalid PCGroup string format: duplicate piece found\");\n          dupe = t;\n        }\n        bag.add(t);\n      }\n    }\n    let dupeBits = 0;\n    if (dupe) {\n      dupeBits = dupe.index << 7;\n    }\n    let bagBits = 0;\n    for (let i = 1; i <= 7; ++i) {\n      if (bag.has(tetrimino(i))) {\n        bagBits |= 1 << 7 - i;\n      }\n    }\n    const result = dupeBits | bagBits;\n    return result;\n  }\n\n  /**\r\n   * Static: Mirror a PCGroup code and return a new PCGroup.\r\n   */\n  static mirror(code) {\n    // Swap a (bit 9) and d (bit 6)\n    let a = code >> 9 & 1;\n    let d = code >> 6 & 1;\n    code = code & ~(1 << 9) | d << 9;\n    code = code & ~(1 << 6) | a << 6;\n\n    // Swap c (bit 7) and f (bit 4)\n    let c = code >> 7 & 1;\n    let f = code >> 4 & 1;\n    code = code & ~(1 << 7) | f << 7;\n    code = code & ~(1 << 4) | c << 4;\n\n    // Swap h (bit 2) and j (bit 0)\n    let h = code >> 2 & 1;\n    let j = code >> 0 & 1;\n    code = code & ~(1 << 2) | j << 2;\n    code = code & ~(1 << 0) | h << 0;\n    return new PCGroup(code);\n  }\n\n  /**\r\n   * Instance: Mirror this PCGroup in-place and return this.\r\n   */\n  mirror() {\n    let code = this.code;\n\n    // Swap a (bit 9) and d (bit 6)\n    let a = code >> 9 & 1;\n    let d = code >> 6 & 1;\n    code = code & ~(1 << 9) | d << 9;\n    code = code & ~(1 << 6) | a << 6;\n\n    // Swap c (bit 7) and f (bit 4)\n    let c = code >> 7 & 1;\n    let f = code >> 4 & 1;\n    code = code & ~(1 << 7) | f << 7;\n    code = code & ~(1 << 4) | c << 4;\n\n    // Swap h (bit 2) and j (bit 0)\n    let h = code >> 2 & 1;\n    let j = code >> 0 & 1;\n    code = code & ~(1 << 2) | j << 2;\n    code = code & ~(1 << 0) | h << 0;\n\n    // Reinitialize this PCGroup with the mirrored code\n    const mirrored = new PCGroup(code);\n    this.code = mirrored.code;\n    this.bag = mirrored.bag;\n    this.duplicate = mirrored.duplicate;\n    return this;\n  }\n  toString() {\n    // Collect all piece letters from group and duplicate\n    const piecesArr = Array.from(this.bag, t => t.toString());\n    if (this.duplicate) {\n      piecesArr.push(this.duplicate.toString());\n    }\n    return normalizedSort(piecesArr.join(\"\"));\n  }\n  getPC() {\n    const queueLength = this.bag.size + (this.duplicate ? 1 : 0);\n    switch (queueLength) {\n      case 0:\n        return PC.FIRST;\n      case 1:\n        return PC.THIRD;\n      case 2:\n        return PC.FIFTH;\n      case 3:\n        return PC.SEVENTH;\n      case 4:\n        return PC.SECOND;\n      case 5:\n        return PC.FOURTH;\n      case 6:\n        return PC.SIXTH;\n      case 7:\n        return PC.FIRST;\n      default:\n        throw new Error(\"Invalid PCGroup\");\n    }\n  }\n  get code() {\n    return this.code;\n  }\n  equals(other) {\n    return this.code === other.code;\n  }\n}","map":{"version":3,"names":["PC","normalizedSort","tetrimino","tetriminos","PCGroup","constructor","arg","bag","duplicate","code","test","toString","parseInt","dupeBits","bagBits","Set","undefined","group","i","add","encodeQueue","pcGroup","Error","str","dupe","toUpperCase","replace","includes","dupeString","bagString","split","length","difference","map","size","t","has","index","result","mirror","a","d","c","f","h","j","mirrored","piecesArr","Array","from","push","join","getPC","queueLength","FIRST","THIRD","FIFTH","SEVENTH","SECOND","FOURTH","SIXTH","equals","other"],"sources":["C:/Stuff/Github/peasea/frontend/src/scripts/PCGroup.ts"],"sourcesContent":["import { PC } from \"./PC\";\r\nimport { normalizedSort } from \"./pieces\";\r\nimport Tetrimino, { tetrimino, tetriminos } from \"./Tetrimino\";\r\n\r\nexport class PCGroup {\r\n    private bag: Set<Tetrimino>;\r\n    private duplicate?: Tetrimino;\r\n    private code: number;\r\n\r\n    constructor(arg: string | number) {\r\n        if (/^\\d+$/.test(arg.toString()) || typeof arg === \"number\") {\r\n            if (typeof arg === \"string\" && !/^\\d+$/.test(arg)) {\r\n                this.code = parseInt(arg, 10);\r\n            } else {\r\n                this.code = arg as number;\r\n            }\r\n            // abc = duplicate (bits 9-7), defghij = group (bits 6-0)\r\n            let dupeBits = (this.code >> 7) & 0b111;\r\n            let bagBits = this.code & 0b1111111;\r\n            // Special case: both 0000000000 and 1111111000 are \"first PC\"\r\n            if (this.code === 0 || this.code === 0b1111111000) {\r\n                this.bag = new Set();\r\n                this.duplicate = undefined;\r\n                return;\r\n            }\r\n            // Invalid: all 1s with nonzero dupe\r\n            if (bagBits === 0b1111111 && dupeBits !== 0) bagBits = 0b0000000;\r\n            // Build group as Set<Tetrimino>\r\n            let group = new Set<Tetrimino>();\r\n            for (let i = 1; i <= 7; ++i) {\r\n                if (bagBits & (1 << (7 - i))) {\r\n                    group.add(tetrimino(i));\r\n                }\r\n            }\r\n            this.bag = group;\r\n            if (dupeBits > 0) {\r\n                this.duplicate = tetrimino(dupeBits);\r\n            }\r\n        } else if (typeof arg === \"string\") {\r\n            this.code = PCGroup.encodeQueue(arg);\r\n            const pcGroup = new PCGroup(this.code);\r\n            this.bag = pcGroup.bag;\r\n            this.duplicate = pcGroup.duplicate;\r\n        } else {\r\n            throw new Error(\"Invalid constructor arguments\");\r\n        }\r\n    }\r\n\r\n    public static encodeQueue(str: string): number {\r\n        let dupe = undefined;\r\n        let bag = new Set<Tetrimino>();\r\n        //get rid of all invalid PCGroup string formats\r\n        str = str\r\n            .toUpperCase()\r\n            .replace(/[^JTSLIZO<>\\-\\+]/g, \"\")\r\n            .replace(\"-\", \">\")\r\n            .replace(\"+\", \"<\");\r\n\r\n        if (str.includes(\">\")) {\r\n            //Format: X>YZ , X is the duplicate piece, YZ is the INVERTED bag.\r\n            if (str.includes(\"<\"))\r\n                throw new Error(\"Invalid PCGroup string format\");\r\n            let [dupeString, bagString] = str.split(\">\");\r\n            if (dupeString.length > 1 || bagString.length > 7)\r\n                throw new Error(\"Invalid PCGroup string format\");\r\n            if (bagString.length === 0) bagString = \"\";\r\n            dupe = tetrimino(dupeString);\r\n            bag = new Set(tetriminos).difference(\r\n                new Set<Tetrimino>(bagString.split(\"\").map(tetrimino))\r\n            );\r\n            if (bag.size !== 7 - bagString.length)\r\n                throw new Error(\"Invalid PCGroup string format\");\r\n        } else if (str.includes(\"<\")) {\r\n            if (str.includes(\">\"))\r\n                throw new Error(\"Invalid PCGroup string format\");\r\n            //Format: X<YZ , X is the duplicate piece, YZ is the bag.\r\n            let [dupeString, bagString] = str.split(\"<\");\r\n            if (dupeString.length > 1 || bagString.length > 7)\r\n                throw new Error(\"Invalid PCGroup string format\");\r\n            dupe = tetrimino(dupeString);\r\n            bag = new Set<Tetrimino>(bagString.split(\"\").map(tetrimino));\r\n            if (bag.size !== bagString.length)\r\n                throw new Error(\"Invalid PCGroup string format\");\r\n        } else {\r\n            //Queue only consists of tetriminos, there can be up to 1 duplicate.\r\n            if (str.length > 7)\r\n                throw new Error(\"Invalid PCGroup string format\");\r\n            dupe = undefined;\r\n            bag = new Set<Tetrimino>();\r\n            for (const t of str.split(\"\").map(tetrimino)) {\r\n                if (bag.has(t)) {\r\n                    if (dupe)\r\n                        throw new Error(\r\n                            \"Invalid PCGroup string format: duplicate piece found\"\r\n                        );\r\n                    dupe = t;\r\n                }\r\n                bag.add(t);\r\n            }\r\n        }\r\n\r\n        let dupeBits = 0;\r\n        if (dupe) {\r\n            dupeBits = dupe.index << 7;\r\n        }\r\n        let bagBits = 0;\r\n        for (let i = 1; i <= 7; ++i) {\r\n            if (bag.has(tetrimino(i))) {\r\n                bagBits |= 1 << (7 - i);\r\n            }\r\n        }\r\n        const result = dupeBits | bagBits;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Static: Mirror a PCGroup code and return a new PCGroup.\r\n     */\r\n    static mirror(code: number): PCGroup {\r\n        // Swap a (bit 9) and d (bit 6)\r\n        let a = (code >> 9) & 1;\r\n        let d = (code >> 6) & 1;\r\n        code = (code & ~(1 << 9)) | (d << 9);\r\n        code = (code & ~(1 << 6)) | (a << 6);\r\n\r\n        // Swap c (bit 7) and f (bit 4)\r\n        let c = (code >> 7) & 1;\r\n        let f = (code >> 4) & 1;\r\n        code = (code & ~(1 << 7)) | (f << 7);\r\n        code = (code & ~(1 << 4)) | (c << 4);\r\n\r\n        // Swap h (bit 2) and j (bit 0)\r\n        let h = (code >> 2) & 1;\r\n        let j = (code >> 0) & 1;\r\n        code = (code & ~(1 << 2)) | (j << 2);\r\n        code = (code & ~(1 << 0)) | (h << 0);\r\n\r\n        return new PCGroup(code);\r\n    }\r\n\r\n    /**\r\n     * Instance: Mirror this PCGroup in-place and return this.\r\n     */\r\n    mirror(): this {\r\n        let code = this.code;\r\n\r\n        // Swap a (bit 9) and d (bit 6)\r\n        let a = (code >> 9) & 1;\r\n        let d = (code >> 6) & 1;\r\n        code = (code & ~(1 << 9)) | (d << 9);\r\n        code = (code & ~(1 << 6)) | (a << 6);\r\n\r\n        // Swap c (bit 7) and f (bit 4)\r\n        let c = (code >> 7) & 1;\r\n        let f = (code >> 4) & 1;\r\n        code = (code & ~(1 << 7)) | (f << 7);\r\n        code = (code & ~(1 << 4)) | (c << 4);\r\n\r\n        // Swap h (bit 2) and j (bit 0)\r\n        let h = (code >> 2) & 1;\r\n        let j = (code >> 0) & 1;\r\n        code = (code & ~(1 << 2)) | (j << 2);\r\n        code = (code & ~(1 << 0)) | (h << 0);\r\n\r\n        // Reinitialize this PCGroup with the mirrored code\r\n        const mirrored = new PCGroup(code);\r\n        this.code = mirrored.code;\r\n        this.bag = mirrored.bag;\r\n        this.duplicate = mirrored.duplicate;\r\n        return this;\r\n    }\r\n\r\n    public toString(): string {\r\n        // Collect all piece letters from group and duplicate\r\n        const piecesArr = Array.from(this.bag, (t) => t.toString());\r\n        if (this.duplicate) {\r\n            piecesArr.push(this.duplicate.toString());\r\n        }\r\n        return normalizedSort(piecesArr.join(\"\"));\r\n    }\r\n\r\n    public getPC(): PC {\r\n        const queueLength = this.bag.size + (this.duplicate ? 1 : 0);\r\n        switch (queueLength) {\r\n            case 0:\r\n                return PC.FIRST;\r\n            case 1:\r\n                return PC.THIRD;\r\n            case 2:\r\n                return PC.FIFTH;\r\n            case 3:\r\n                return PC.SEVENTH;\r\n            case 4:\r\n                return PC.SECOND;\r\n            case 5:\r\n                return PC.FOURTH;\r\n            case 6:\r\n                return PC.SIXTH;\r\n            case 7:\r\n                return PC.FIRST;\r\n            default:\r\n                throw new Error(\"Invalid PCGroup\");\r\n        }\r\n    }\r\n\r\n    get code(): number {\r\n        return this.code;\r\n    }\r\n\r\n    public equals(other: PCGroup): boolean {\r\n        return this.code === other.code;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}