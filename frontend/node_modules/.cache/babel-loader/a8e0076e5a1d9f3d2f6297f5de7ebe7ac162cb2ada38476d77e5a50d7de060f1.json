{"ast":null,"code":"import { PC } from \"./PC\";\nimport { normalizedSort, pieces } from \"./pieces\";\nexport class PCGroup {\n  // Constructor to initialize the queue and PC\n  constructor(queue, pc) {\n    this.queue = void 0;\n    this.normalizedQueue = void 0;\n    this.pc = void 0;\n    this.queue = queue;\n    this.normalizedQueue = normalizedSort(queue);\n    this.pc = pc;\n  }\n  getQueue() {\n    return this.queue;\n  }\n  getNormalizedQueue() {\n    return this.normalizedQueue;\n  }\n  getPC() {\n    return this.pc;\n  }\n\n  // Method to validate if the queue matches the group\n  static validateQueue(queue) {\n    for (const char of queue) {\n      var _queue$match$length, _queue$match;\n      if (((_queue$match$length = (_queue$match = queue.match(new RegExp(char))) === null || _queue$match === void 0 ? void 0 : _queue$match.length) !== null && _queue$match$length !== void 0 ? _queue$match$length : 0) > 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Factory method to create the appropriate group based on the queue\n  static from(queue) {\n    let normalizedQueue = normalizedSort(queue);\n    if (!this.validateQueue(normalizedQueue)) return null;\n    switch (normalizedQueue.length) {\n      case 7:\n        return new FirstGroup(queue);\n      case 4:\n        return new SecondGroup(queue);\n      case 1:\n        return new ThirdGroup(queue);\n      case 5:\n        return new FourthGroup(queue);\n      case 2:\n        return new FifthGroup(queue);\n      case 6:\n        return new SixthGroup(queue);\n      case 3:\n        return new SeventhGroup(queue);\n    }\n    return null;\n  }\n}\nPCGroup.FIRSTS = pieces(\"[**c7]c7\");\nPCGroup.SECONDS = pieces(\"[**c7]c4\");\nPCGroup.THIRDS = pieces(\"[**c7]\");\nPCGroup.FOURTHS = pieces(\"[**c7]c5\");\nPCGroup.FIFTHS = pieces(\"[**c7]2\");\nPCGroup.SIXTHS = pieces(\"[**c7]c6\");\nPCGroup.SEVENTHS = pieces(\"[**c7]c3\");\nexport class FirstGroup extends PCGroup {\n  constructor(queue) {\n    super(queue, PC.FIRST);\n  }\n}\nexport class SecondGroup extends PCGroup {\n  constructor(queue) {\n    super(queue, PC.SECOND);\n  }\n}\nexport class ThirdGroup extends PCGroup {\n  constructor(queue) {\n    super(queue, PC.THIRD);\n  }\n}\nexport class FourthGroup extends PCGroup {\n  constructor(queue) {\n    super(queue, PC.FOURTH);\n  }\n}\nexport class FifthGroup extends PCGroup {\n  constructor(queue) {\n    super(queue, PC.FIFTH);\n  }\n}\nexport class SixthGroup extends PCGroup {\n  constructor(queue) {\n    super(queue, PC.SIXTH);\n  }\n}\nexport class SeventhGroup extends PCGroup {\n  constructor(queue) {\n    super(queue, PC.SEVENTH);\n  }\n}","map":{"version":3,"names":["PC","normalizedSort","pieces","PCGroup","constructor","queue","pc","normalizedQueue","getQueue","getNormalizedQueue","getPC","validateQueue","char","_queue$match$length","_queue$match","match","RegExp","length","from","FirstGroup","SecondGroup","ThirdGroup","FourthGroup","FifthGroup","SixthGroup","SeventhGroup","FIRSTS","SECONDS","THIRDS","FOURTHS","FIFTHS","SIXTHS","SEVENTHS","FIRST","SECOND","THIRD","FOURTH","FIFTH","SIXTH","SEVENTH"],"sources":["C:/Stuff/Github/peasea/frontend/src/scripts/PCGroup.ts"],"sourcesContent":["import { PC } from \"./PC\";\r\nimport { normalizedSort, pieces } from \"./pieces\";\r\n\r\nexport abstract class PCGroup {\r\n    private static FIRSTS   = pieces(`[**c7]c7`);\r\n    private static SECONDS  = pieces(`[**c7]c4`);\r\n    private static THIRDS   = pieces(`[**c7]`);\r\n    private static FOURTHS  = pieces(`[**c7]c5`);\r\n    private static FIFTHS   = pieces(`[**c7]2`);\r\n    private static SIXTHS   = pieces(`[**c7]c6`);\r\n    private static SEVENTHS = pieces(`[**c7]c3`);\r\n\r\n    private queue: string;\r\n    private normalizedQueue: string;\r\n    private pc: PC;\r\n\r\n    // Constructor to initialize the queue and PC\r\n    constructor(queue: string, pc: PC) {\r\n        this.queue = queue;\r\n        this.normalizedQueue = normalizedSort(queue);\r\n        this.pc = pc;\r\n    }\r\n\r\n    public getQueue():string {\r\n        return this.queue;\r\n    }\r\n\r\n    public getNormalizedQueue():string {\r\n        return this.normalizedQueue;\r\n    }\r\n\r\n    public getPC():PC {\r\n        return this.pc;\r\n    }\r\n\r\n    // Method to validate if the queue matches the group\r\n    private static validateQueue(queue: string): boolean {\r\n        for(const char of queue) {\r\n            if((queue.match(new RegExp(char))?.length??0) > 1){\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n\r\n    // Factory method to create the appropriate group based on the queue\r\n    static from(queue: string): PCGroup | null {\r\n        let normalizedQueue = normalizedSort(queue)\r\n        if(!this.validateQueue(normalizedQueue))return null;\r\n        switch(normalizedQueue.length){\r\n            case 7:\r\n                return new FirstGroup(queue);\r\n            case 4:\r\n                return new SecondGroup(queue);\r\n            case 1:\r\n                return new ThirdGroup(queue);\r\n            case 5:\r\n                return new FourthGroup(queue);\r\n            case 2:\r\n                return new FifthGroup(queue);\r\n            case 6:\r\n                return new SixthGroup(queue);\r\n            case 3:\r\n                return new SeventhGroup(queue); \r\n        }\r\n        return null;\r\n    }\r\n    \r\n}\r\nexport class FirstGroup extends PCGroup {\r\n    constructor(queue: string){\r\n        super(queue,PC.FIRST);\r\n    }\r\n}\r\nexport class SecondGroup extends PCGroup {\r\n    constructor(queue: string){\r\n        super(queue,PC.SECOND);\r\n    }\r\n}\r\nexport class ThirdGroup extends PCGroup {\r\n    constructor(queue: string){\r\n        super(queue,PC.THIRD);\r\n    }\r\n}\r\nexport class FourthGroup extends PCGroup {\r\n    constructor(queue: string){\r\n        super(queue,PC.FOURTH);\r\n    }\r\n}\r\nexport class FifthGroup extends PCGroup {\r\n    constructor(queue: string){\r\n        super(queue,PC.FIFTH);\r\n    }\r\n}\r\nexport class SixthGroup extends PCGroup {\r\n    constructor(queue: string){\r\n        super(queue,PC.SIXTH);\r\n    }\r\n}\r\nexport class SeventhGroup extends PCGroup {\r\n    constructor(queue: string){\r\n        super(queue,PC.SEVENTH);\r\n    }\r\n}\r\n\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}