{"ast":null,"code":"function checkPieces(queue, pieces) {\n  // Remove non-useful characters (mostly [])\n  pieces = pieces.replaceAll(\"*\", \"[TIJLOSZ]\");\n  pieces = pieces.replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\n\n  // Initialize an empty string for the queue copy (to manipulate as we process pieces)\n  let remainingQueue = queue;\n  console.log(\"Initial queue:\", remainingQueue);\n\n  // Process each set and its count\n  for (let [_, set, count = 1] of Array.from(pieces.matchAll(/((?<=\\[)[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\n    console.log(\"Processing set:\", set, \"with count:\", count);\n\n    // Handle inversion\n    if (set.startsWith(\"^\")) {\n      set = \"TIJLOSZ\".split(\"\").filter(piece => !set.includes(piece)).join(\"\");\n      console.log(\"Inverted set:\", set);\n    }\n\n    // Handle the count logic\n    count = count === \"!\" ? set.length : Number(count);\n\n    // Check if count exceeds the set's length\n    if (count > set.length) {\n      console.log(\"Count exceeds set length, returning false\");\n      return false;\n    }\n\n    // Handle matching the queue with the pieces set\n    let matchedPieces = 0;\n    for (let piece of set) {\n      // If a piece from the set is found in the remaining queue, remove it from the queue\n      if (remainingQueue.includes(piece)) {\n        remainingQueue = remainingQueue.replace(piece, \"\"); // Remove the matched piece from the queue\n        matchedPieces++;\n        console.log(\"Matched piece: \".concat(piece, \", remaining queue: \").concat(remainingQueue));\n      }\n    }\n\n    // If there aren't enough matches in the queue or the queue is not long enough, return false\n    if (matchedPieces !== count || remainingQueue.length < 0) {\n      console.log(\"Not enough matched pieces or queue mismatch, returning false\");\n      return false;\n    }\n\n    // Handle uniqueness constraint for the `!` operator\n    if (count === set.length && remainingQueue.includes(set)) {\n      // If `!` is used, ensure there are no duplicates in the queue\n      if (new Set(remainingQueue).size !== remainingQueue.length) {\n        console.log(\"Queue contains duplicates, returning false\");\n        return false;\n      }\n    }\n  }\n\n  // If the remaining queue has unmatched pieces, it should be empty to be valid\n  console.log(\"Final remaining queue:\", remainingQueue);\n  return remainingQueue.length === 0;\n}\n\n// Test cases:\n\nconsole.log(checkPieces(\"IJS\", \"[IJLS]!\")); // false (queue does not match length)\nconsole.log(checkPieces(\"JSLI\", \"[IJLS]!\")); // true\nconsole.log(checkPieces(\"IJLST\", \"[IJLS]!\")); // false (extra pieces)\n\nconsole.log(checkPieces(\"TISTS\", \"[TIJLS]p3[TOS]!\")); // true\nconsole.log(checkPieces(\"TSSTO\", \"[TIJLS]p3[TOS]!\")); // false (duplicate pieces)\nconsole.log(checkPieces(\"TZSTOS\", \"[TIJLS]p3[TOS]!\")); // false (z not in the first bag)\n\n/*// Main method to check if a queue belongs to a set\r\n  export default function pieces(queue: string, set: string): boolean {\r\n    console.log(`Queue: ${queue}, Set: ${set}`);\r\n    var [pieces, modifiers] = set.split('{');\r\n    if(modifiers?.endsWith('}'))modifiers = modifiers.slice(0, modifiers.length - 1);\r\n    console.log(`Pieces: ${pieces}, Modifiers: ${modifiers}`);\r\n    \r\n    const queuePieces = pieces.trim();\r\n    return true;\r\n  }\r\n  \r\n  \r\n  \r\n  console.log(pieces(\"IJLS\", \"[IJLS]!{S<3}\"));\r\n  */\nexport default checkPieces;","map":{"version":3,"names":["checkPieces","queue","pieces","replaceAll","remainingQueue","console","log","_","set","count","Array","from","matchAll","startsWith","split","filter","piece","includes","join","length","Number","matchedPieces","replace","concat","Set","size"],"sources":["C:/Stuff/Github/peasea/src/scripts/pieces.tsx"],"sourcesContent":["function checkPieces(queue: string, pieces: string): boolean {\r\n    // Remove non-useful characters (mostly [])\r\n    pieces = pieces.replaceAll(\"*\", \"[TIJLOSZ]\");\r\n    pieces = pieces.replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\r\n\r\n    // Initialize an empty string for the queue copy (to manipulate as we process pieces)\r\n    let remainingQueue = queue;\r\n    console.log(\"Initial queue:\", remainingQueue);\r\n\r\n    // Process each set and its count\r\n    for (let [_, set, count = 1] of Array.from(pieces.matchAll(/((?<=\\[)[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\r\n        console.log(\"Processing set:\", set, \"with count:\", count);\r\n\r\n        // Handle inversion\r\n        if (set.startsWith(\"^\")) {\r\n            set = \"TIJLOSZ\".split(\"\").filter(piece => !set.includes(piece)).join(\"\");\r\n            console.log(\"Inverted set:\", set);\r\n        }\r\n\r\n        // Handle the count logic\r\n        count = count === \"!\" ? set.length : Number(count);\r\n\r\n        // Check if count exceeds the set's length\r\n        if (count > set.length) {\r\n            console.log(\"Count exceeds set length, returning false\");\r\n            return false;\r\n        }\r\n\r\n        // Handle matching the queue with the pieces set\r\n        let matchedPieces = 0;\r\n        for (let piece of set) {\r\n            // If a piece from the set is found in the remaining queue, remove it from the queue\r\n            if (remainingQueue.includes(piece)) {\r\n                remainingQueue = remainingQueue.replace(piece, \"\"); // Remove the matched piece from the queue\r\n                matchedPieces++;\r\n                console.log(`Matched piece: ${piece}, remaining queue: ${remainingQueue}`);\r\n            }\r\n        }\r\n\r\n        // If there aren't enough matches in the queue or the queue is not long enough, return false\r\n        if (matchedPieces !== count || remainingQueue.length < 0) {\r\n            console.log(\"Not enough matched pieces or queue mismatch, returning false\");\r\n            return false;\r\n        }\r\n\r\n        // Handle uniqueness constraint for the `!` operator\r\n        if (count === set.length && remainingQueue.includes(set)) {\r\n            // If `!` is used, ensure there are no duplicates in the queue\r\n            if (new Set(remainingQueue).size !== remainingQueue.length) {\r\n                console.log(\"Queue contains duplicates, returning false\");\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // If the remaining queue has unmatched pieces, it should be empty to be valid\r\n    console.log(\"Final remaining queue:\", remainingQueue);\r\n    return remainingQueue.length === 0;\r\n}\r\n\r\n// Test cases:\r\n\r\nconsole.log(checkPieces(\"IJS\", \"[IJLS]!\")); // false (queue does not match length)\r\nconsole.log(checkPieces(\"JSLI\", \"[IJLS]!\")); // true\r\nconsole.log(checkPieces(\"IJLST\", \"[IJLS]!\")); // false (extra pieces)\r\n\r\nconsole.log(checkPieces(\"TISTS\", \"[TIJLS]p3[TOS]!\")); // true\r\nconsole.log(checkPieces(\"TSSTO\", \"[TIJLS]p3[TOS]!\")); // false (duplicate pieces)\r\nconsole.log(checkPieces(\"TZSTOS\", \"[TIJLS]p3[TOS]!\")); // false (z not in the first bag)\r\n\r\n\r\n\r\n/*// Main method to check if a queue belongs to a set\r\n  export default function pieces(queue: string, set: string): boolean {\r\n    console.log(`Queue: ${queue}, Set: ${set}`);\r\n    var [pieces, modifiers] = set.split('{');\r\n    if(modifiers?.endsWith('}'))modifiers = modifiers.slice(0, modifiers.length - 1);\r\n    console.log(`Pieces: ${pieces}, Modifiers: ${modifiers}`);\r\n    \r\n    const queuePieces = pieces.trim();\r\n    return true;\r\n  }\r\n  \r\n  \r\n  \r\n  console.log(pieces(\"IJLS\", \"[IJLS]!{S<3}\"));\r\n  */\r\nexport default checkPieces;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}