{"ast":null,"code":"import { normalizedSort } from \"./pieces\";\nimport Tetrimino from \"./Tetrimino\";\nexport class PCGroup {\n  /**\r\n   * Construct a PCGroup from a 10-bit code (0-1016).\r\n   * Throws if code is out of range.\r\n   * Format: 0xabcdefghij, where abc = duplicate, defghij = group\r\n   */\n  constructor(code) {\n    this.group = void 0;\n    this.duplicate = void 0;\n    this.code = void 0;\n    if (!Number.isInteger(code)) {\n      throw new RangeError(\"PCGroup code must be an integer\");\n    }\n    this.code = code;\n    // abc = duplicate (bits 9-7), defghij = group (bits 6-0)\n    let dupeBits = code >> 7 & 0b111;\n    let bagBits = code & 0b1111111;\n    // Special case: both 0000000000 and 1111111000 are \"first PC\"\n    if (code === 0 || code === 0b1111111000) {\n      this.group = new Set();\n      this.duplicate = undefined;\n      return;\n    }\n    // Invalid: all 1s with nonzero dupe\n    if (bagBits === 0b1111111 && dupeBits !== 0) {\n      throw new RangeError(\"PCGroup code invalid.\");\n    }\n    // Build group as Set<Tetrimino>\n    let group = new Set();\n    for (let i = 0; i < 7; ++i) {\n      if (bagBits & 1 << 6 - i) {\n        group.add(new Tetrimino(PCGroup.pieceOrder[i]));\n      }\n    }\n    this.group = group;\n    if (dupeBits > 0) {\n      this.duplicate = new Tetrimino(PCGroup.pieceOrder[dupeBits - 1]);\n    }\n  }\n\n  /**\r\n   * Static: Mirror a PCGroup code and return a new PCGroup.\r\n   */\n  static mirror(code) {\n    // Swap a (bit 9) and d (bit 6)\n    let a = code >> 9 & 1;\n    let d = code >> 6 & 1;\n    code = code & ~(1 << 9) | d << 9;\n    code = code & ~(1 << 6) | a << 6;\n\n    // Swap c (bit 7) and f (bit 4)\n    let c = code >> 7 & 1;\n    let f = code >> 4 & 1;\n    code = code & ~(1 << 7) | f << 7;\n    code = code & ~(1 << 4) | c << 4;\n\n    // Swap h (bit 2) and j (bit 0)\n    let h = code >> 2 & 1;\n    let j = code >> 0 & 1;\n    code = code & ~(1 << 2) | j << 2;\n    code = code & ~(1 << 0) | h << 0;\n    return new PCGroup(code);\n  }\n\n  /**\r\n   * Instance: Mirror this PCGroup in-place and return this.\r\n   */\n  mirror() {\n    let code = this.code;\n\n    // Swap a (bit 9) and d (bit 6)\n    let a = code >> 9 & 1;\n    let d = code >> 6 & 1;\n    code = code & ~(1 << 9) | d << 9;\n    code = code & ~(1 << 6) | a << 6;\n\n    // Swap c (bit 7) and f (bit 4)\n    let c = code >> 7 & 1;\n    let f = code >> 4 & 1;\n    code = code & ~(1 << 7) | f << 7;\n    code = code & ~(1 << 4) | c << 4;\n\n    // Swap h (bit 2) and j (bit 0)\n    let h = code >> 2 & 1;\n    let j = code >> 0 & 1;\n    code = code & ~(1 << 2) | j << 2;\n    code = code & ~(1 << 0) | h << 0;\n\n    // Reinitialize this PCGroup with the mirrored code\n    const mirrored = new PCGroup(code);\n    this.code = mirrored.code;\n    this.group = mirrored.group;\n    this.duplicate = mirrored.duplicate;\n    return this;\n  }\n  toString() {\n    // Collect all piece letters from group and duplicate\n    const piecesArr = Array.from(this.group, t => t.toString());\n    if (this.duplicate) {\n      piecesArr.push(this.duplicate.toString());\n    }\n    return normalizedSort(piecesArr.join(\"\"));\n  }\n}\nPCGroup.pieceOrder = ['J', 'T', 'S', 'L', 'I', 'Z', 'O'];","map":{"version":3,"names":["normalizedSort","Tetrimino","PCGroup","constructor","code","group","duplicate","Number","isInteger","RangeError","dupeBits","bagBits","Set","undefined","i","add","pieceOrder","mirror","a","d","c","f","h","j","mirrored","toString","piecesArr","Array","from","t","push","join"],"sources":["C:/Stuff/Github/peasea/frontend/src/scripts/PCGroup.ts"],"sourcesContent":["import { PC } from \"./PC\";\r\nimport { normalizedSort, pieces } from \"./pieces\";\r\nimport Tetrimino from \"./Tetrimino\";\r\n\r\nexport class PCGroup {\r\n    private static pieceOrder = ['J', 'T', 'S', 'L', 'I', 'Z', 'O'];\r\n\r\n    group: Set<Tetrimino>;\r\n    duplicate?: Tetrimino;\r\n    code: number;\r\n\r\n    /**\r\n     * Construct a PCGroup from a 10-bit code (0-1016).\r\n     * Throws if code is out of range.\r\n     * Format: 0xabcdefghij, where abc = duplicate, defghij = group\r\n     */\r\n    constructor(code: number) {\r\n        if (!Number.isInteger(code)) {\r\n            throw new RangeError(\"PCGroup code must be an integer\");\r\n        }\r\n        this.code = code;\r\n        // abc = duplicate (bits 9-7), defghij = group (bits 6-0)\r\n        let dupeBits = (code >> 7) & 0b111;\r\n        let bagBits = code & 0b1111111;\r\n        // Special case: both 0000000000 and 1111111000 are \"first PC\"\r\n        if (code === 0 || code === 0b1111111000) {\r\n            this.group = new Set();\r\n            this.duplicate = undefined;\r\n            return;\r\n        }\r\n        // Invalid: all 1s with nonzero dupe\r\n        if (bagBits === 0b1111111 && dupeBits !== 0) {\r\n            throw new RangeError(\"PCGroup code invalid.\");\r\n        }\r\n        // Build group as Set<Tetrimino>\r\n        let group = new Set<Tetrimino>();\r\n        for (let i = 0; i < 7; ++i) {\r\n            if (bagBits & (1 << (6 - i))) {\r\n                group.add(new Tetrimino(PCGroup.pieceOrder[i] as any));\r\n            }\r\n        }\r\n        this.group = group;\r\n        if (dupeBits > 0) {\r\n            this.duplicate = new Tetrimino(PCGroup.pieceOrder[dupeBits - 1] as any);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static: Mirror a PCGroup code and return a new PCGroup.\r\n     */\r\n    static mirror(code: number): PCGroup {\r\n        // Swap a (bit 9) and d (bit 6)\r\n        let a = (code >> 9) & 1;\r\n        let d = (code >> 6) & 1;\r\n        code = (code & ~(1 << 9)) | (d << 9);\r\n        code = (code & ~(1 << 6)) | (a << 6);\r\n\r\n        // Swap c (bit 7) and f (bit 4)\r\n        let c = (code >> 7) & 1;\r\n        let f = (code >> 4) & 1;\r\n        code = (code & ~(1 << 7)) | (f << 7);\r\n        code = (code & ~(1 << 4)) | (c << 4);\r\n\r\n        // Swap h (bit 2) and j (bit 0)\r\n        let h = (code >> 2) & 1;\r\n        let j = (code >> 0) & 1;\r\n        code = (code & ~(1 << 2)) | (j << 2);\r\n        code = (code & ~(1 << 0)) | (h << 0);\r\n\r\n        return new PCGroup(code);\r\n    }\r\n\r\n    /**\r\n     * Instance: Mirror this PCGroup in-place and return this.\r\n     */\r\n    mirror(): this {\r\n        let code = this.code;\r\n\r\n        // Swap a (bit 9) and d (bit 6)\r\n        let a = (code >> 9) & 1;\r\n        let d = (code >> 6) & 1;\r\n        code = (code & ~(1 << 9)) | (d << 9);\r\n        code = (code & ~(1 << 6)) | (a << 6);\r\n\r\n        // Swap c (bit 7) and f (bit 4)\r\n        let c = (code >> 7) & 1;\r\n        let f = (code >> 4) & 1;\r\n        code = (code & ~(1 << 7)) | (f << 7);\r\n        code = (code & ~(1 << 4)) | (c << 4);\r\n\r\n        // Swap h (bit 2) and j (bit 0)\r\n        let h = (code >> 2) & 1;\r\n        let j = (code >> 0) & 1;\r\n        code = (code & ~(1 << 2)) | (j << 2);\r\n        code = (code & ~(1 << 0)) | (h << 0);\r\n\r\n        // Reinitialize this PCGroup with the mirrored code\r\n        const mirrored = new PCGroup(code);\r\n        this.code = mirrored.code;\r\n        this.group = mirrored.group;\r\n        this.duplicate = mirrored.duplicate;\r\n        return this;\r\n    }\r\n\r\n    public toString(): string {\r\n        // Collect all piece letters from group and duplicate\r\n        const piecesArr = Array.from(this.group, t => t.toString());\r\n        if (this.duplicate) {\r\n            piecesArr.push(this.duplicate.toString());\r\n        }\r\n        return normalizedSort(piecesArr.join(\"\"));\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}