{"ast":null,"code":"const PIECES = \"TIJLOSZ\";\n\n//get rid of it\nexport function sortByPCOrder(a, b) {\n  return PIECES.indexOf(a) - PIECES.indexOf(b);\n}\n\n//good\nexport function normalizedSort(input) {\n  const counts = {\n    T: 0,\n    I: 0,\n    J: 0,\n    L: 0,\n    O: 0,\n    S: 0,\n    Z: 0\n  };\n  for (const char of input) {\n    if (PIECES.includes(char)) {\n      counts[char]++;\n    }\n  }\n  return Object.entries(counts).sort((_ref, _ref2) => {\n    let [pieceA, countA] = _ref;\n    let [pieceB, countB] = _ref2;\n    return countB - countA || PIECES.indexOf(pieceA) - PIECES.indexOf(pieceB);\n  }) // TIJLOSZ order\n  .flatMap(_ref3 => {\n    let [piece, count] = _ref3;\n    return Array(count).fill(piece);\n  }).join('');\n}\n\n//good\nfunction normalizeInput(input) {\n  // 1. Remove invalid syntax\n  let cleaned = input.replace(/[^TIJLOSZX\\[\\]\\^\\!\\*\\dpc]/g, \"\");\n\n  // 2. Inversion: [^TIJ] → [LOSZ]\n  cleaned = cleaned.replace(/\\[\\^([A-Z]+)\\]/g, (_, negated) => PIECES.split(\"\").filter(c => !negated.includes(c)).join(\"\"));\n\n  // 3. Replace [*...] → [expanded]\n  cleaned = cleaned.replace(/\\[([^\\]]*?)\\]/g, (_, inner) => {\n    const expanded = inner.replace(/\\*/g, PIECES);\n    return \"[\".concat(expanded, \"]\");\n  });\n\n  // 4. Replace lone * outside of brackets with [TIJLOSZ]\n  cleaned = cleaned.replace(/\\*/g, \"[\".concat(PIECES, \"]\"));\n\n  // 5. Replace [XYZ]! → [XYZ]pN\n  cleaned = cleaned.replace(/\\[([A-Z]+)\\]!/g, (_, bag) => \"[\".concat(bag, \"]p\").concat(bag.length));\n\n  // 6. Replace [XYZ]N → [XYZ]pN\n  cleaned = cleaned.replace(/\\[([A-Z]+)\\](\\d)/g, (_, bag, n) => \"[\".concat(bag, \"]p\").concat(n));\n\n  // 7. Replace bare [XYZ] → [XYZ]p1\n  cleaned = cleaned.replace(/\\[([A-Z]+)\\](?![pc]\\d)/g, (_, bag) => \"[\".concat(bag, \"]p1\"));\n  cleaned = cleaned.replace(/X/g, \"[TIJLOSZ]p1\");\n  return cleaned;\n}\nfunction getPermutations(str, length) {\n  if (typeof str !== \"string\") {\n    return str.map(s => getPermutations(s, length)).flat();\n  }\n  const results = new Set();\n  const chars = normalizedSort(str);\n  function backtrack(path, used) {\n    if (path.length === length) {\n      results.add(path.join(\"\"));\n      return;\n    }\n    for (let i = 0; i < chars.length; i++) {\n      if (used[i]) continue;\n      // Skip duplicates\n      if (i > 0 && chars[i] === chars[i - 1] && !used[i - 1]) continue;\n      used[i] = true;\n      path.push(chars[i]);\n      backtrack(path, used);\n      path.pop();\n      used[i] = false;\n    }\n  }\n  backtrack([], Array(str.length).fill(false));\n  return Array.from(results);\n}\nfunction getCombinations(str, length) {\n  if (typeof str !== \"string\") {\n    return str.map(s => getCombinations(s, length)).flat();\n  }\n  const sorted = normalizedSort(str);\n  const results = [];\n  function backtrack(start, path) {\n    if (path.length === length) {\n      results.push(path.join(\"\"));\n      return;\n    }\n    for (let i = start; i < sorted.length; i++) {\n      path.push(sorted[i]);\n      backtrack(i + 1, path);\n      path.pop();\n    }\n  }\n  backtrack(0, []);\n  return results;\n}\nexport function pieces(input) {\n  input = normalizeInput(input);\n  const parts = [];\n  console.log(input);\n  if (input.split('').every(c => PIECES.includes(c))) {\n    return [input];\n  }\n  let bag = \"\";\n  let mode = \"\";\n  let num = 0;\n  for (const char of input) {\n    if (bag) {\n      bag += char;\n      if (char === \"]\") {\n        bag = \"\";\n      }\n    } else {\n      if (/[pc]/.test(char)) {\n        mode = char;\n      } else if (/\\d/.test(char)) {\n        num = Number(char);\n        if (mode === \"p\") {\n          parts.push(getPermutations(pieces(bag), num));\n        } else if (mode === \"c\") {\n          parts.push(getCombinations(pieces(bag), num));\n        }\n      } else if (PIECES.includes(char)) {\n        parts.push([char]);\n      }\n    }\n  }\n  return cartesianProduct(parts);\n}\nfunction cartesianProduct(arrays) {\n  return arrays.reduce((acc, curr) => {\n    const result = [];\n    for (const a of acc) {\n      for (const b of curr) {\n        result.push(a + b);\n      }\n    }\n    return result;\n  }, [\"\"]);\n}\nexport function checkPieces(queue, pattern) {\n  //Fix queue (remove unnessesary pieces, replace * with [TIJLOSZ].)\n  pattern = pattern.replaceAll(/\\*/g, \"[TIJLOSZ]\").replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\n\n  //Iterate through each bag and compare to queue\n  for (let [_, set, count = 1] of Array.from(pattern.matchAll(/((?<=\\[)\\^?[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\n    set = set.startsWith(\"^\") ? \"TIJLOSZ\".split(\"\").filter(piece => !set.includes(piece)).join(\"\") : set;\n    count = count === \"!\" ? set.length : Number(count);\n    if (queue.length < count || set.length < count) return false;\n    for (let piece of queue.substring(0, count)) {\n      if (!set.includes(piece)) return false;\n      set = set.replace(piece, \"\");\n    }\n    queue = queue.substring(count, queue.length);\n  }\n  return !queue.length;\n}\nfunction checkModifiers(queue, pattern) {\n  return false;\n}\n\n// export default function pieces(queue: string, pattern: string): boolean {\n//     console.log(`Queue: ${queue}, Set: ${pattern}`);\n//     var [pattern, modifiers] = pattern.split(\"{\");\n//     if (modifiers?.endsWith(\"}\"))\n//         modifiers = modifiers.slice(0, modifiers.length - 1);\n//     console.log(`Pattern: ${pattern}, Modifiers: ${modifiers}`);\n\n//     const queuePieces = queue.trim();\n//     return checkPieces(queuePieces, pattern);\n// }","map":{"version":3,"names":["PIECES","sortByPCOrder","a","b","indexOf","normalizedSort","input","counts","T","I","J","L","O","S","Z","char","includes","Object","entries","sort","_ref","_ref2","pieceA","countA","pieceB","countB","flatMap","_ref3","piece","count","Array","fill","join","normalizeInput","cleaned","replace","_","negated","split","filter","c","inner","expanded","concat","bag","length","n","getPermutations","str","map","s","flat","results","Set","chars","backtrack","path","used","add","i","push","pop","from","getCombinations","sorted","start","pieces","parts","console","log","every","mode","num","test","Number","cartesianProduct","arrays","reduce","acc","curr","result","checkPieces","queue","pattern","replaceAll","set","matchAll","startsWith","substring","checkModifiers"],"sources":["C:/Stuff/Github/peasea/frontend/src/scripts/pieces.ts"],"sourcesContent":["const PIECES = \"TIJLOSZ\";\r\n\r\n//get rid of it\r\nexport function sortByPCOrder(a:string,b:string){\r\n    return PIECES.indexOf(a)-PIECES.indexOf(b);\r\n}\r\n\r\n//good\r\nexport function normalizedSort(input: string): string {\r\n    const counts: Record<string, number> = {T:0,I:0,J:0,L:0,O:0,S:0,Z:0};\r\n    for (const char of input) {\r\n        if (PIECES.includes(char)) {\r\n            counts[char]++;\r\n        }\r\n    }\r\n    return Object.entries(counts)\r\n        .sort(([pieceA, countA], [pieceB, countB]) => (countB - countA) || PIECES.indexOf(pieceA) - PIECES.indexOf(pieceB)) // TIJLOSZ order\r\n        .flatMap(([piece, count]) => Array(count).fill(piece))\r\n        .join('');\r\n}\r\n\r\n//good\r\nfunction normalizeInput(input: string): string {\r\n    \r\n    // 1. Remove invalid syntax\r\n    let cleaned = input.replace(/[^TIJLOSZX\\[\\]\\^\\!\\*\\dpc]/g, \"\");\r\n\r\n    // 2. Inversion: [^TIJ] → [LOSZ]\r\n    cleaned = cleaned.replace(/\\[\\^([A-Z]+)\\]/g, (_, negated) => PIECES.split(\"\").filter(c => !negated.includes(c)).join(\"\"));\r\n\r\n    // 3. Replace [*...] → [expanded]\r\n    cleaned = cleaned.replace(/\\[([^\\]]*?)\\]/g, (_, inner) => {\r\n        const expanded = inner.replace(/\\*/g, PIECES);\r\n        return `[${expanded}]`;\r\n    });\r\n\r\n    // 4. Replace lone * outside of brackets with [TIJLOSZ]\r\n    cleaned = cleaned.replace(/\\*/g, `[${PIECES}]`);\r\n\r\n    // 5. Replace [XYZ]! → [XYZ]pN\r\n    cleaned = cleaned.replace(/\\[([A-Z]+)\\]!/g, (_, bag) => `[${bag}]p${bag.length}`);\r\n\r\n    // 6. Replace [XYZ]N → [XYZ]pN\r\n    cleaned = cleaned.replace(/\\[([A-Z]+)\\](\\d)/g, (_, bag, n) => `[${bag}]p${n}`);\r\n\r\n    // 7. Replace bare [XYZ] → [XYZ]p1\r\n    cleaned = cleaned.replace(/\\[([A-Z]+)\\](?![pc]\\d)/g, (_, bag) => `[${bag}]p1`);\r\n\r\n    cleaned = cleaned.replace(/X/g,`[TIJLOSZ]p1`)\r\n\r\n    return cleaned;\r\n}\r\n\r\n\r\n\r\nfunction getPermutations(str: string|string[], length: number): string[] {\r\n    if(typeof str !== \"string\") {\r\n        return str.map(s=>getPermutations(s, length)).flat();\r\n    }\r\n    const results: Set<string> = new Set();\r\n    const chars = normalizedSort(str);\r\n\r\n    function backtrack(path: string[], used: boolean[]) {\r\n        if (path.length === length) {\r\n            results.add(path.join(\"\"));\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < chars.length; i++) {\r\n            if (used[i]) continue;\r\n            // Skip duplicates\r\n            if (i > 0 && chars[i] === chars[i - 1] && !used[i - 1]) continue;\r\n\r\n            used[i] = true;\r\n            path.push(chars[i]);\r\n            backtrack(path, used);\r\n            path.pop();\r\n            used[i] = false;\r\n        }\r\n    }\r\n\r\n    backtrack([], Array(str.length).fill(false));\r\n    return Array.from(results);\r\n}\r\n\r\n\r\nfunction getCombinations(str: string|string[], length: number): string[] {\r\n    if(typeof str !== \"string\") {\r\n        return str.map(s=>getCombinations(s, length)).flat();\r\n    }\r\n    const sorted = normalizedSort(str);\r\n    const results: string[] = [];\r\n\r\n    function backtrack(start: number, path: string[]) {\r\n        if (path.length === length) {\r\n            results.push(path.join(\"\"));\r\n            return;\r\n        }\r\n        for (let i = start; i < sorted.length; i++) {\r\n            path.push(sorted[i]);\r\n            backtrack(i + 1, path);\r\n            path.pop();\r\n        }\r\n    }\r\n\r\n    backtrack(0, []);\r\n    return results;\r\n}\r\n\r\nexport function pieces(input: string): string[] {\r\n    input = normalizeInput(input);\r\n    const parts: string[][] = [];\r\n    console.log(input);\r\n    if(input.split('').every(c=>PIECES.includes(c))){\r\n        return [input];\r\n    }\r\n    \r\n    let bag = \"\";\r\n    let mode = \"\";\r\n    let num = 0;\r\n    for(const char of input){\r\n        if(bag){\r\n            bag += char;\r\n            if(char === \"]\"){\r\n                bag = \"\";\r\n            }\r\n        }else{\r\n            if(/[pc]/.test(char)){\r\n                mode = char;\r\n            }else if (/\\d/.test(char)){\r\n                num = Number(char);\r\n                if(mode === \"p\"){\r\n                    parts.push(getPermutations(pieces(bag), num));\r\n                }else if(mode === \"c\"){\r\n                    parts.push(getCombinations(pieces(bag), num));\r\n                }\r\n            }else if(PIECES.includes(char)){\r\n                parts.push([char]);\r\n            }\r\n\r\n        }\r\n        \r\n    }\r\n    return cartesianProduct(parts);\r\n}\r\nfunction cartesianProduct(arrays: string[][]): string[] {\r\n    return arrays.reduce((acc, curr) => {\r\n        const result: string[] = [];\r\n        for (const a of acc) {\r\n            for (const b of curr) {\r\n                result.push(a + b);\r\n            }\r\n        }\r\n        return result;\r\n    }, [\"\"]);\r\n}\r\n\r\nexport function checkPieces(queue: string, pattern: string): boolean {\r\n    //Fix queue (remove unnessesary pieces, replace * with [TIJLOSZ].)\r\n    pattern = pattern.replaceAll(/\\*/g, \"[TIJLOSZ]\").replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\r\n\r\n\r\n    //Iterate through each bag and compare to queue\r\n    for (let [_, set, count = 1] of Array.from(pattern.matchAll(/((?<=\\[)\\^?[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\r\n        set = set.startsWith(\"^\") ? \"TIJLOSZ\".split(\"\").filter((piece) => !set.includes(piece)).join(\"\") : set;\r\n        count = count === \"!\" ? set.length : Number(count);\r\n        if(queue.length < count || set.length < count)return false;\r\n\r\n        for (let piece of queue.substring(0, count)) {\r\n            if (!set.includes(piece)) return false;\r\n            set = set.replace(piece, \"\");\r\n        }\r\n        queue = queue.substring(count, queue.length);\r\n    }\r\n\r\n    return !queue.length;\r\n}\r\n\r\n\r\nfunction checkModifiers(queue: string, pattern: string): boolean {\r\n    \r\n    \r\n    return false;\r\n}\r\n\r\n// export default function pieces(queue: string, pattern: string): boolean {\r\n//     console.log(`Queue: ${queue}, Set: ${pattern}`);\r\n//     var [pattern, modifiers] = pattern.split(\"{\");\r\n//     if (modifiers?.endsWith(\"}\"))\r\n//         modifiers = modifiers.slice(0, modifiers.length - 1);\r\n//     console.log(`Pattern: ${pattern}, Modifiers: ${modifiers}`);\r\n\r\n//     const queuePieces = queue.trim();\r\n//     return checkPieces(queuePieces, pattern);\r\n// }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}