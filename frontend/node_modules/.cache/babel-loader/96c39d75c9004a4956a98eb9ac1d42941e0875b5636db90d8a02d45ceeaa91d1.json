{"ast":null,"code":"import { PC } from \"./PC\";\nimport { normalizedSort } from \"./pieces\";\nimport Tetrimino from \"./Tetrimino\";\nexport class PCGroup {\n  constructor(arg, access) {\n    this.bag = void 0;\n    this.duplicate = void 0;\n    this.code = void 0;\n    if (typeof arg === \"number\") {\n      if (!Number.isInteger(arg)) {\n        throw new RangeError(\"PCGroup code must be an integer\");\n      }\n      this.code = arg;\n      // abc = duplicate (bits 9-7), defghij = group (bits 6-0)\n      let dupeBits = arg >> 7 & 0b111;\n      let bagBits = arg & 0b1111111;\n      // Special case: both 0000000000 and 1111111000 are \"first PC\"\n      if (arg === 0 || arg === 0b1111111000) {\n        this.bag = new Set();\n        this.duplicate = undefined;\n        return;\n      }\n      // Invalid: all 1s with nonzero dupe\n      if (bagBits === 0b1111111 && dupeBits !== 0) {\n        throw new RangeError(\"PCGroup code invalid.\");\n      }\n      // Build group as Set<Tetrimino>\n      let group = new Set();\n      for (let i = 0; i < 7; ++i) {\n        if (bagBits & 1 << 6 - i) {\n          group.add(new Tetrimino(PCGroup.pieceOrder[i]));\n        }\n      }\n      this.bag = group;\n      if (dupeBits > 0) {\n        this.duplicate = new Tetrimino(PCGroup.pieceOrder[dupeBits - 1]);\n      }\n    } else if (typeof arg === \"string\") {\n      const queue = arg.toUpperCase();\n      const seen = new Map();\n      for (const c of queue) {\n        var _seen$get;\n        seen.set(c, ((_seen$get = seen.get(c)) !== null && _seen$get !== void 0 ? _seen$get : 0) + 1);\n      }\n      // Validate only valid pieces\n      for (const c of seen.keys()) {\n        if (!PCGroup.pieceOrder.includes(c)) {\n          throw new Error(\"Invalid piece '\".concat(c, \"' in queue\"));\n        }\n      }\n      // Check for too many duplicates\n      const dupes = Array.from(seen.entries()).filter(_ref => {\n        let [_, v] = _ref;\n        return v > 1;\n      });\n      if (!access && dupes.length > 1) {\n        throw new Error(\"Multiple duplicate pieces in queue\");\n      }\n      if (!access && dupes.length === 1 && dupes[0][1] > 2) {\n        throw new Error(\"More than two of the same piece in queue\");\n      }\n      this.bag = new Set();\n      this.duplicate = undefined;\n      if (access) {\n        // First piece is duplicate, rest are group\n        if (queue.length === 0) {\n          throw new Error(\"Queue string is empty\");\n        }\n        this.duplicate = new Tetrimino(queue[0]);\n        for (let i = 1; i < queue.length; ++i) {\n          this.bag.add(new Tetrimino(queue[i]));\n        }\n      } else {\n        // If there is a duplicate, one goes to duplicate, one to group\n        let usedDuplicate = false;\n        for (const c of queue) {\n          if (seen.get(c) > 1 && !usedDuplicate) {\n            this.duplicate = new Tetrimino(c);\n            seen.set(c, seen.get(c) - 1);\n            usedDuplicate = true;\n          } else {\n            this.bag.add(new Tetrimino(c));\n          }\n        }\n      }\n      // Set code (optional: you may want to implement encoding logic here)\n      this.code = 0; // Placeholder, as code is not defined for string input\n    } else {\n      throw new Error(\"Invalid constructor arguments\");\n    }\n  }\n\n  /**\r\n   * Static: Mirror a PCGroup code and return a new PCGroup.\r\n   */\n  static mirror(code) {\n    // Swap a (bit 9) and d (bit 6)\n    let a = code >> 9 & 1;\n    let d = code >> 6 & 1;\n    code = code & ~(1 << 9) | d << 9;\n    code = code & ~(1 << 6) | a << 6;\n\n    // Swap c (bit 7) and f (bit 4)\n    let c = code >> 7 & 1;\n    let f = code >> 4 & 1;\n    code = code & ~(1 << 7) | f << 7;\n    code = code & ~(1 << 4) | c << 4;\n\n    // Swap h (bit 2) and j (bit 0)\n    let h = code >> 2 & 1;\n    let j = code >> 0 & 1;\n    code = code & ~(1 << 2) | j << 2;\n    code = code & ~(1 << 0) | h << 0;\n    return new PCGroup(code);\n  }\n\n  /**\r\n   * Instance: Mirror this PCGroup in-place and return this.\r\n   */\n  mirror() {\n    let code = this.code;\n\n    // Swap a (bit 9) and d (bit 6)\n    let a = code >> 9 & 1;\n    let d = code >> 6 & 1;\n    code = code & ~(1 << 9) | d << 9;\n    code = code & ~(1 << 6) | a << 6;\n\n    // Swap c (bit 7) and f (bit 4)\n    let c = code >> 7 & 1;\n    let f = code >> 4 & 1;\n    code = code & ~(1 << 7) | f << 7;\n    code = code & ~(1 << 4) | c << 4;\n\n    // Swap h (bit 2) and j (bit 0)\n    let h = code >> 2 & 1;\n    let j = code >> 0 & 1;\n    code = code & ~(1 << 2) | j << 2;\n    code = code & ~(1 << 0) | h << 0;\n\n    // Reinitialize this PCGroup with the mirrored code\n    const mirrored = new PCGroup(code);\n    this.code = mirrored.code;\n    this.bag = mirrored.bag;\n    this.duplicate = mirrored.duplicate;\n    return this;\n  }\n  toString() {\n    // Collect all piece letters from group and duplicate\n    const piecesArr = Array.from(this.bag, t => t.toString());\n    if (this.duplicate) {\n      piecesArr.push(this.duplicate.toString());\n    }\n    return normalizedSort(piecesArr.join(\"\"));\n  }\n  getPC() {\n    const queueLength = this.bag.size + (this.duplicate ? 1 : 0);\n    switch (queueLength) {\n      case 1:\n        return PC.FIRST;\n      case 2:\n        return PC.SECOND;\n      case 3:\n        return PC.THIRD;\n      case 4:\n        return PC.FOURTH;\n      case 5:\n        return PC.FIFTH;\n      case 6:\n        return PC.SIXTH;\n      case 7:\n        return PC.SEVENTH;\n      default:\n        throw new Error(\"Invalid queue length for PCGroup\");\n    }\n  }\n}\nPCGroup.pieceOrder = ['J', 'T', 'S', 'L', 'I', 'Z', 'O'];","map":{"version":3,"names":["PC","normalizedSort","Tetrimino","PCGroup","constructor","arg","access","bag","duplicate","code","Number","isInteger","RangeError","dupeBits","bagBits","Set","undefined","group","i","add","pieceOrder","queue","toUpperCase","seen","Map","c","_seen$get","set","get","keys","includes","Error","concat","dupes","Array","from","entries","filter","_ref","_","v","length","usedDuplicate","mirror","a","d","f","h","j","mirrored","toString","piecesArr","t","push","join","getPC","queueLength","size","FIRST","SECOND","THIRD","FOURTH","FIFTH","SIXTH","SEVENTH"],"sources":["C:/Stuff/Github/peasea/frontend/src/scripts/PCGroup.ts"],"sourcesContent":["import { PC } from \"./PC\";\r\nimport { normalizedSort, pieces } from \"./pieces\";\r\nimport Tetrimino from \"./Tetrimino\";\r\n\r\nexport class PCGroup {\r\n    private static pieceOrder = ['J', 'T', 'S', 'L', 'I', 'Z', 'O'];\r\n\r\n    bag: Set<Tetrimino>;\r\n    duplicate?: Tetrimino;\r\n    code: number;\r\n\r\n    constructor(arg: number | string, access?: boolean) {\r\n        if (typeof arg === \"number\") {\r\n            if (!Number.isInteger(arg)) {\r\n                throw new RangeError(\"PCGroup code must be an integer\");\r\n            }\r\n            this.code = arg;\r\n            // abc = duplicate (bits 9-7), defghij = group (bits 6-0)\r\n            let dupeBits = (arg >> 7) & 0b111;\r\n            let bagBits = arg & 0b1111111;\r\n            // Special case: both 0000000000 and 1111111000 are \"first PC\"\r\n            if (arg === 0 || arg === 0b1111111000) {\r\n                this.bag = new Set();\r\n                this.duplicate = undefined;\r\n                return;\r\n            }\r\n            // Invalid: all 1s with nonzero dupe\r\n            if (bagBits === 0b1111111 && dupeBits !== 0) {\r\n                throw new RangeError(\"PCGroup code invalid.\");\r\n            }\r\n            // Build group as Set<Tetrimino>\r\n            let group = new Set<Tetrimino>();\r\n            for (let i = 0; i < 7; ++i) {\r\n                if (bagBits & (1 << (6 - i))) {\r\n                    group.add(new Tetrimino(PCGroup.pieceOrder[i] as any));\r\n                }\r\n            }\r\n            this.bag = group;\r\n            if (dupeBits > 0) {\r\n                this.duplicate = new Tetrimino(PCGroup.pieceOrder[dupeBits - 1] as any);\r\n            }\r\n        } else if (typeof arg === \"string\") {\r\n            const queue = arg.toUpperCase();\r\n            const seen = new Map<string, number>();\r\n            for (const c of queue) {\r\n                seen.set(c, (seen.get(c) ?? 0) + 1);\r\n            }\r\n            // Validate only valid pieces\r\n            for (const c of seen.keys()) {\r\n                if (!PCGroup.pieceOrder.includes(c)) {\r\n                    throw new Error(`Invalid piece '${c}' in queue`);\r\n                }\r\n            }\r\n            // Check for too many duplicates\r\n            const dupes = Array.from(seen.entries()).filter(([_, v]) => v > 1);\r\n            if (!access && dupes.length > 1) {\r\n                throw new Error(\"Multiple duplicate pieces in queue\");\r\n            }\r\n            if (!access && dupes.length === 1 && dupes[0][1] > 2) {\r\n                throw new Error(\"More than two of the same piece in queue\");\r\n            }\r\n            this.bag = new Set<Tetrimino>();\r\n            this.duplicate = undefined;\r\n            if (access) {\r\n                // First piece is duplicate, rest are group\r\n                if (queue.length === 0) {\r\n                    throw new Error(\"Queue string is empty\");\r\n                }\r\n                this.duplicate = new Tetrimino(queue[0] as any);\r\n                for (let i = 1; i < queue.length; ++i) {\r\n                    this.bag.add(new Tetrimino(queue[i] as any));\r\n                }\r\n            } else {\r\n                // If there is a duplicate, one goes to duplicate, one to group\r\n                let usedDuplicate = false;\r\n                for (const c of queue) {\r\n                    if (seen.get(c)! > 1 && !usedDuplicate) {\r\n                        this.duplicate = new Tetrimino(c as any);\r\n                        seen.set(c, seen.get(c)! - 1);\r\n                        usedDuplicate = true;\r\n                    } else {\r\n                        this.bag.add(new Tetrimino(c as any));\r\n                    }\r\n                }\r\n            }\r\n            // Set code (optional: you may want to implement encoding logic here)\r\n            this.code = 0; // Placeholder, as code is not defined for string input\r\n        } else {\r\n            throw new Error(\"Invalid constructor arguments\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static: Mirror a PCGroup code and return a new PCGroup.\r\n     */\r\n    static mirror(code: number): PCGroup {\r\n        // Swap a (bit 9) and d (bit 6)\r\n        let a = (code >> 9) & 1;\r\n        let d = (code >> 6) & 1;\r\n        code = (code & ~(1 << 9)) | (d << 9);\r\n        code = (code & ~(1 << 6)) | (a << 6);\r\n\r\n        // Swap c (bit 7) and f (bit 4)\r\n        let c = (code >> 7) & 1;\r\n        let f = (code >> 4) & 1;\r\n        code = (code & ~(1 << 7)) | (f << 7);\r\n        code = (code & ~(1 << 4)) | (c << 4);\r\n\r\n        // Swap h (bit 2) and j (bit 0)\r\n        let h = (code >> 2) & 1;\r\n        let j = (code >> 0) & 1;\r\n        code = (code & ~(1 << 2)) | (j << 2);\r\n        code = (code & ~(1 << 0)) | (h << 0);\r\n\r\n        return new PCGroup(code);\r\n    }\r\n\r\n    /**\r\n     * Instance: Mirror this PCGroup in-place and return this.\r\n     */\r\n    mirror(): this {\r\n        let code = this.code;\r\n\r\n        // Swap a (bit 9) and d (bit 6)\r\n        let a = (code >> 9) & 1;\r\n        let d = (code >> 6) & 1;\r\n        code = (code & ~(1 << 9)) | (d << 9);\r\n        code = (code & ~(1 << 6)) | (a << 6);\r\n\r\n        // Swap c (bit 7) and f (bit 4)\r\n        let c = (code >> 7) & 1;\r\n        let f = (code >> 4) & 1;\r\n        code = (code & ~(1 << 7)) | (f << 7);\r\n        code = (code & ~(1 << 4)) | (c << 4);\r\n\r\n        // Swap h (bit 2) and j (bit 0)\r\n        let h = (code >> 2) & 1;\r\n        let j = (code >> 0) & 1;\r\n        code = (code & ~(1 << 2)) | (j << 2);\r\n        code = (code & ~(1 << 0)) | (h << 0);\r\n\r\n        // Reinitialize this PCGroup with the mirrored code\r\n        const mirrored = new PCGroup(code);\r\n        this.code = mirrored.code;\r\n        this.bag = mirrored.bag;\r\n        this.duplicate = mirrored.duplicate;\r\n        return this;\r\n    }\r\n\r\n    public toString(): string {\r\n        // Collect all piece letters from group and duplicate\r\n        const piecesArr = Array.from(this.bag, t => t.toString());\r\n        if (this.duplicate) {\r\n            piecesArr.push(this.duplicate.toString());\r\n        }\r\n        return normalizedSort(piecesArr.join(\"\"));\r\n    }\r\n\r\n    public getPC(): PC {\r\n        const queueLength = this.bag.size + (this.duplicate ? 1 : 0);\r\n        switch (queueLength) {\r\n            case 1: return PC.FIRST;\r\n            case 2: return PC.SECOND;\r\n            case 3: return PC.THIRD;\r\n            case 4: return PC.FOURTH;\r\n            case 5: return PC.FIFTH;\r\n            case 6: return PC.SIXTH;\r\n            case 7: return PC.SEVENTH;\r\n            default: throw new Error(\"Invalid queue length for PCGroup\");\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}