{"ast":null,"code":"function checkPieces(queue, pieces) {\n  // Remove non-useful characters (mostly [])\n  pieces = pieces.replaceAll(\"*\", \"[TIJLOSZ]\");\n  pieces = pieces.replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\n  for (let [_, set, count = 1] of Array.from(pieces.matchAll(/((?<=\\[)[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\n    if (set.startsWith(\"^\")) set = \"TIJLOSZ\".split(\"\").filter(piece => !set.includes(piece)).join(\"\");\n    count = count === \"!\" ? set.length : Number(count);\n    console.log(set, count);\n    if (count > set.length || count > queue.length) return false;\n\n    // Handle matching the queue with the pieces set\n    let matchedPieces = 0;\n    for (let piece of set) {\n      // If a piece from the set is found in the remaining queue, remove it from the queue\n      if (queue.includes(piece)) {\n        queue = queue.replace(piece, \"\"); // Remove the matched piece from the queue\n        matchedPieces++;\n      }\n    }\n\n    // If there aren't enough matches in the queue or the queue is not long enough, return false\n    if (matchedPieces !== count || queue.length < 0) {\n      return false;\n    }\n\n    // Handle uniqueness constraint for the `!` operator\n    if (count === set.length && queue.includes(set)) {\n      // If `!` is used, ensure there are no duplicates in the queue\n      if (new Set(queue).size !== queue.length) {\n        return false;\n      }\n    }\n    console.log(set, count, queue);\n  }\n\n  // If the remaining queue has unmatched pieces, it should be empty to be valid\n  return queue.length === 0;\n}\n\n/*// Main method to check if a queue belongs to a set\r\n  export default function pieces(queue: string, set: string): boolean {\r\n    console.log(`Queue: ${queue}, Set: ${set}`);\r\n    var [pieces, modifiers] = set.split('{');\r\n    if(modifiers?.endsWith('}'))modifiers = modifiers.slice(0, modifiers.length - 1);\r\n    console.log(`Pieces: ${pieces}, Modifiers: ${modifiers}`);\r\n    \r\n    const queuePieces = pieces.trim();\r\n    return true;\r\n  }\r\n  \r\n  \r\n  \r\n  console.log(pieces(\"IJLS\", \"[IJLS]!{S<3}\"));\r\n  */\nexport default checkPieces;","map":{"version":3,"names":["checkPieces","queue","pieces","replaceAll","_","set","count","Array","from","matchAll","startsWith","split","filter","piece","includes","join","length","Number","console","log","matchedPieces","replace","Set","size"],"sources":["C:/Stuff/Github/peasea/src/scripts/pieces.tsx"],"sourcesContent":["function checkPieces(queue: string, pieces: string): boolean {\r\n    // Remove non-useful characters (mostly [])\r\n    pieces = pieces.replaceAll(\"*\", \"[TIJLOSZ]\");\r\n    pieces = pieces.replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\r\n\r\n    for (let [_, set, count = 1] of Array.from(pieces.matchAll(/((?<=\\[)[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\r\n        \r\n        if (set.startsWith(\"^\")) set = \"TIJLOSZ\".split(\"\").filter(piece => !set.includes(piece)).join(\"\");\r\n        count = count === \"!\" ? set.length : Number(count);\r\n\r\n        console.log(set,count);\r\n        if(count > set.length || count > queue.length)return false;\r\n\r\n\r\n        // Handle matching the queue with the pieces set\r\n        let matchedPieces = 0;\r\n        for (let piece of set) {\r\n            // If a piece from the set is found in the remaining queue, remove it from the queue\r\n            if (queue.includes(piece)) {\r\n                queue = queue.replace(piece, \"\"); // Remove the matched piece from the queue\r\n                matchedPieces++;\r\n            }\r\n        }\r\n\r\n        // If there aren't enough matches in the queue or the queue is not long enough, return false\r\n        if (matchedPieces !== count || queue.length < 0) {\r\n            return false;\r\n        }\r\n\r\n        // Handle uniqueness constraint for the `!` operator\r\n        if (count === set.length && queue.includes(set)) {\r\n            // If `!` is used, ensure there are no duplicates in the queue\r\n            if (new Set(queue).size !== queue.length) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        console.log(set, count, queue);\r\n    }\r\n\r\n    // If the remaining queue has unmatched pieces, it should be empty to be valid\r\n    return queue.length === 0;\r\n}\r\n\r\n\r\n/*// Main method to check if a queue belongs to a set\r\n  export default function pieces(queue: string, set: string): boolean {\r\n    console.log(`Queue: ${queue}, Set: ${set}`);\r\n    var [pieces, modifiers] = set.split('{');\r\n    if(modifiers?.endsWith('}'))modifiers = modifiers.slice(0, modifiers.length - 1);\r\n    console.log(`Pieces: ${pieces}, Modifiers: ${modifiers}`);\r\n    \r\n    const queuePieces = pieces.trim();\r\n    return true;\r\n  }\r\n  \r\n  \r\n  \r\n  console.log(pieces(\"IJLS\", \"[IJLS]!{S<3}\"));\r\n  */\r\nexport default checkPieces;\r\n"],"mappings":"AAAA,SAASA,WAAWA,CAACC,KAAa,EAAEC,MAAc,EAAW;EACzD;EACAA,MAAM,GAAGA,MAAM,CAACC,UAAU,CAAC,GAAG,EAAE,WAAW,CAAC;EAC5CD,MAAM,GAAGA,MAAM,CAACC,UAAU,CAAC,sBAAsB,EAAE,EAAE,CAAC;EAEtD,KAAK,IAAI,CAACC,CAAC,EAAEC,GAAG,EAAEC,KAAK,GAAG,CAAC,CAAC,IAAIC,KAAK,CAACC,IAAI,CAACN,MAAM,CAACO,QAAQ,CAAC,0DAA0D,CAAC,CAAC,EAAE;IAErH,IAAIJ,GAAG,CAACK,UAAU,CAAC,GAAG,CAAC,EAAEL,GAAG,GAAG,SAAS,CAACM,KAAK,CAAC,EAAE,CAAC,CAACC,MAAM,CAACC,KAAK,IAAI,CAACR,GAAG,CAACS,QAAQ,CAACD,KAAK,CAAC,CAAC,CAACE,IAAI,CAAC,EAAE,CAAC;IACjGT,KAAK,GAAGA,KAAK,KAAK,GAAG,GAAGD,GAAG,CAACW,MAAM,GAAGC,MAAM,CAACX,KAAK,CAAC;IAElDY,OAAO,CAACC,GAAG,CAACd,GAAG,EAACC,KAAK,CAAC;IACtB,IAAGA,KAAK,GAAGD,GAAG,CAACW,MAAM,IAAIV,KAAK,GAAGL,KAAK,CAACe,MAAM,EAAC,OAAO,KAAK;;IAG1D;IACA,IAAII,aAAa,GAAG,CAAC;IACrB,KAAK,IAAIP,KAAK,IAAIR,GAAG,EAAE;MACnB;MACA,IAAIJ,KAAK,CAACa,QAAQ,CAACD,KAAK,CAAC,EAAE;QACvBZ,KAAK,GAAGA,KAAK,CAACoB,OAAO,CAACR,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC;QAClCO,aAAa,EAAE;MACnB;IACJ;;IAEA;IACA,IAAIA,aAAa,KAAKd,KAAK,IAAIL,KAAK,CAACe,MAAM,GAAG,CAAC,EAAE;MAC7C,OAAO,KAAK;IAChB;;IAEA;IACA,IAAIV,KAAK,KAAKD,GAAG,CAACW,MAAM,IAAIf,KAAK,CAACa,QAAQ,CAACT,GAAG,CAAC,EAAE;MAC7C;MACA,IAAI,IAAIiB,GAAG,CAACrB,KAAK,CAAC,CAACsB,IAAI,KAAKtB,KAAK,CAACe,MAAM,EAAE;QACtC,OAAO,KAAK;MAChB;IACJ;IAEAE,OAAO,CAACC,GAAG,CAACd,GAAG,EAAEC,KAAK,EAAEL,KAAK,CAAC;EAClC;;EAEA;EACA,OAAOA,KAAK,CAACe,MAAM,KAAK,CAAC;AAC7B;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAehB,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}