{"ast":null,"code":"const ORDER = \"TIJLOSZ\";\nconst ALL_PIECES = \"TIJLOSZ\";\nfunction sortByPCOrder(a, b) {\n  return ORDER.indexOf(a) - ORDER.indexOf(b);\n}\nfunction normalizeInput(input) {\n  let cleaned = input.replace(/[\\s,&]/g, \"\");\n\n  // 1. Handle inversion: [^XYZ] -> [complement]\n  cleaned = cleaned.replace(/\\[\\^([A-Z]+)\\]/g, (_, negated) => {\n    const inverted = ALL_PIECES.split(\"\").filter(c => !negated.includes(c)).join(\"\");\n    return \"[\".concat(inverted, \"]\");\n  });\n\n  // 2. Replace [*...] where * is within a bag\n  cleaned = cleaned.replace(/\\[([^\\]]*?)\\]/g, (_, inner) => {\n    const expanded = inner.replace(/\\*/g, ALL_PIECES);\n    return \"[\".concat(expanded, \"]\");\n  });\n\n  // 3. Replace * outside of bags with [TIJLOSZ]p1\n  cleaned = cleaned.replace(/\\*/g, \"[\".concat(ALL_PIECES, \"]p1\"));\n\n  // 4. Handle ! inside bags: [XYZ]! -> [XYZ]pN\n  cleaned = cleaned.replace(/\\[([A-Z]+)\\]!/g, (_, bag) => \"[\".concat(bag, \"]p\").concat(bag.length));\n\n  // 5. [XYZ]N -> [XYZ]pN\n  cleaned = cleaned.replace(/\\[([A-Z]+)\\](\\d)/g, (_, bag, n) => \"[\".concat(bag, \"]p\").concat(n));\n\n  // 6. Bare [XYZ] -> [XYZ]p1\n  cleaned = cleaned.replace(/\\[([A-Z]+)\\](?!p\\d|c\\d)/g, (_, bag) => \"[\".concat(bag, \"]p1\"));\n\n  // 7. Raw chars like ABCp2 → [ABC]p2\n  cleaned = cleaned.replace(/([A-Z]+)([pc])(\\d)/g, (_, bag, mode, n) => \"[\".concat(bag, \"]\").concat(mode).concat(n));\n  return cleaned;\n}\nfunction getPermutations(str, length) {\n  const results = new Set();\n  const chars = str.split('').sort(); // Sort to make deduplication easier\n\n  function backtrack(path, used) {\n    if (path.length === length) {\n      results.add(path.join(\"\"));\n      return;\n    }\n    for (let i = 0; i < chars.length; i++) {\n      if (used[i]) continue;\n      // Skip duplicates\n      if (i > 0 && chars[i] === chars[i - 1] && !used[i - 1]) continue;\n      used[i] = true;\n      path.push(chars[i]);\n      backtrack(path, used);\n      path.pop();\n      used[i] = false;\n    }\n  }\n  backtrack([], Array(str.length).fill(false));\n  return Array.from(results);\n}\nfunction getCombinations(str, length) {\n  const sorted = [...str].sort(sortByPCOrder);\n  const results = [];\n  function backtrack(start, path) {\n    if (path.length === length) {\n      results.push(path.join(\"\"));\n      return;\n    }\n    for (let i = start; i < sorted.length; i++) {\n      path.push(sorted[i]);\n      backtrack(i + 1, path);\n      path.pop();\n    }\n  }\n  backtrack(0, []);\n  return results;\n}\nexport default function pieces(input) {\n  input = normalizeInput(input);\n  console.log(input);\n  const parts = [];\n  const regex = /\\[([A-Z]+)\\](p|c)(\\d)|[A-Z]+/g;\n  let match;\n  while ((match = regex.exec(input)) !== null) {\n    if (match[1]) {\n      const chars = match[1];\n      const type = match[2];\n      const amount = parseInt(match[3]);\n      if (type === \"p\") {\n        parts.push(getPermutations(chars, amount));\n      } else {\n        parts.push(getCombinations(chars, amount));\n      }\n    } else {\n      parts.push([match[0]]); // Fixed pieces like \"T\"\n    }\n  }\n\n  // Cartesian product of all parts\n  function cartesianProduct(arrays) {\n    return arrays.reduce((acc, curr) => {\n      const result = [];\n      for (const a of acc) {\n        for (const b of curr) {\n          result.push(a + b);\n        }\n      }\n      return result;\n    }, [\"\"]);\n  }\n  return cartesianProduct(parts);\n}\nfunction checkPieces(queue, pattern) {\n  //Fix queue (remove unnessesary pieces, replace * with [TIJLOSZ].)\n  pattern = pattern.replaceAll(/\\*/g, \"[TIJLOSZ]\").replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\n\n  //Iterate through each bag and compare to queue\n  for (let [_, set, count = 1] of Array.from(pattern.matchAll(/((?<=\\[)\\^?[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\n    set = set.startsWith(\"^\") ? \"TIJLOSZ\".split(\"\").filter(piece => !set.includes(piece)).join(\"\") : set;\n    count = count === \"!\" ? set.length : Number(count);\n    if (queue.length < count || set.length < count) return false;\n    for (let piece of queue.substring(0, count)) {\n      if (!set.includes(piece)) return false;\n      set = set.replace(piece, \"\");\n    }\n    queue = queue.substring(count, queue.length);\n  }\n  return !queue.length;\n}\nfunction checkModifiers(queue, pattern) {\n  return false;\n}\n\n// export default function pieces(queue: string, pattern: string): boolean {\n//     console.log(`Queue: ${queue}, Set: ${pattern}`);\n//     var [pattern, modifiers] = pattern.split(\"{\");\n//     if (modifiers?.endsWith(\"}\"))\n//         modifiers = modifiers.slice(0, modifiers.length - 1);\n//     console.log(`Pattern: ${pattern}, Modifiers: ${modifiers}`);\n\n//     const queuePieces = queue.trim();\n//     return checkPieces(queuePieces, pattern);\n// }","map":{"version":3,"names":["ORDER","ALL_PIECES","sortByPCOrder","a","b","indexOf","normalizeInput","input","cleaned","replace","_","negated","inverted","split","filter","c","includes","join","concat","inner","expanded","bag","length","n","mode","getPermutations","str","results","Set","chars","sort","backtrack","path","used","add","i","push","pop","Array","fill","from","getCombinations","sorted","start","pieces","console","log","parts","regex","match","exec","type","amount","parseInt","cartesianProduct","arrays","reduce","acc","curr","result","checkPieces","queue","pattern","replaceAll","set","count","matchAll","startsWith","piece","Number","substring","checkModifiers"],"sources":["C:/Stuff/Github/peasea/frontend/src/scripts/pieces.tsx"],"sourcesContent":["const ORDER = \"TIJLOSZ\";\r\nconst ALL_PIECES = \"TIJLOSZ\";\r\n\r\n\r\nfunction sortByPCOrder(a: string, b: string) {\r\n    return ORDER.indexOf(a) - ORDER.indexOf(b);\r\n}\r\nfunction normalizeInput(input: string): string {\r\n    let cleaned = input.replace(/[\\s,&]/g, \"\");\r\n\r\n    // 1. Handle inversion: [^XYZ] -> [complement]\r\n    cleaned = cleaned.replace(/\\[\\^([A-Z]+)\\]/g, (_, negated) => {\r\n        const inverted = ALL_PIECES.split(\"\").filter(c => !negated.includes(c)).join(\"\");\r\n        return `[${inverted}]`;\r\n    });\r\n\r\n    // 2. Replace [*...] where * is within a bag\r\n    cleaned = cleaned.replace(/\\[([^\\]]*?)\\]/g, (_, inner) => {\r\n        const expanded = inner.replace(/\\*/g, ALL_PIECES);\r\n        return `[${expanded}]`;\r\n    });\r\n\r\n    // 3. Replace * outside of bags with [TIJLOSZ]p1\r\n    cleaned = cleaned.replace(/\\*/g, `[${ALL_PIECES}]p1`);\r\n\r\n    // 4. Handle ! inside bags: [XYZ]! -> [XYZ]pN\r\n    cleaned = cleaned.replace(/\\[([A-Z]+)\\]!/g, (_, bag) => `[${bag}]p${bag.length}`);\r\n\r\n    // 5. [XYZ]N -> [XYZ]pN\r\n    cleaned = cleaned.replace(/\\[([A-Z]+)\\](\\d)/g, (_, bag, n) => `[${bag}]p${n}`);\r\n\r\n    // 6. Bare [XYZ] -> [XYZ]p1\r\n    cleaned = cleaned.replace(/\\[([A-Z]+)\\](?!p\\d|c\\d)/g, (_, bag) => `[${bag}]p1`);\r\n\r\n    // 7. Raw chars like ABCp2 → [ABC]p2\r\n    cleaned = cleaned.replace(/([A-Z]+)([pc])(\\d)/g, (_, bag, mode, n) => `[${bag}]${mode}${n}`);\r\n\r\n    return cleaned;\r\n}\r\n\r\n\r\n\r\nfunction getPermutations(str: string, length: number): string[] {\r\n    const results: Set<string> = new Set();\r\n    const chars = str.split('').sort(); // Sort to make deduplication easier\r\n\r\n    function backtrack(path: string[], used: boolean[]) {\r\n        if (path.length === length) {\r\n            results.add(path.join(\"\"));\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < chars.length; i++) {\r\n            if (used[i]) continue;\r\n            // Skip duplicates\r\n            if (i > 0 && chars[i] === chars[i - 1] && !used[i - 1]) continue;\r\n\r\n            used[i] = true;\r\n            path.push(chars[i]);\r\n            backtrack(path, used);\r\n            path.pop();\r\n            used[i] = false;\r\n        }\r\n    }\r\n\r\n    backtrack([], Array(str.length).fill(false));\r\n    return Array.from(results);\r\n}\r\n\r\n\r\nfunction getCombinations(str: string, length: number): string[] {\r\n    const sorted = [...str].sort(sortByPCOrder);\r\n    const results: string[] = [];\r\n\r\n    function backtrack(start: number, path: string[]) {\r\n        if (path.length === length) {\r\n            results.push(path.join(\"\"));\r\n            return;\r\n        }\r\n        for (let i = start; i < sorted.length; i++) {\r\n            path.push(sorted[i]);\r\n            backtrack(i + 1, path);\r\n            path.pop();\r\n        }\r\n    }\r\n\r\n    backtrack(0, []);\r\n    return results;\r\n}\r\n\r\nexport default function pieces(input: string): string[] {\r\n    input = normalizeInput(input);\r\n    console.log(input);\r\n    \r\n    const parts: string[][] = [];\r\n    const regex = /\\[([A-Z]+)\\](p|c)(\\d)|[A-Z]+/g;\r\n    let match;\r\n\r\n    while ((match = regex.exec(input)) !== null) {\r\n        if (match[1]) {\r\n            const chars = match[1];\r\n            const type = match[2];\r\n            const amount = parseInt(match[3]);\r\n            if (type === \"p\") {\r\n                parts.push(getPermutations(chars, amount));\r\n            } else {\r\n                parts.push(getCombinations(chars, amount));\r\n            }\r\n        } else {\r\n            parts.push([match[0]]); // Fixed pieces like \"T\"\r\n        }\r\n    }\r\n\r\n    // Cartesian product of all parts\r\n    function cartesianProduct(arrays: string[][]): string[] {\r\n        return arrays.reduce((acc, curr) => {\r\n            const result: string[] = [];\r\n            for (const a of acc) {\r\n                for (const b of curr) {\r\n                    result.push(a + b);\r\n                }\r\n            }\r\n            return result;\r\n        }, [\"\"]);\r\n    }\r\n\r\n    return cartesianProduct(parts);\r\n}\r\n\r\nfunction checkPieces(queue: string, pattern: string): boolean {\r\n    //Fix queue (remove unnessesary pieces, replace * with [TIJLOSZ].)\r\n    pattern = pattern.replaceAll(/\\*/g, \"[TIJLOSZ]\").replaceAll(/[^\\[\\]^!TIJLOSZ0-7]/g, \"\");\r\n\r\n\r\n    //Iterate through each bag and compare to queue\r\n    for (let [_, set, count = 1] of Array.from(pattern.matchAll(/((?<=\\[)\\^?[TIJLOSZ]{0,7}(?=\\])|[TIJLOSZ])\\]?(?:([!0-7]))?/g))) {\r\n        set = set.startsWith(\"^\") ? \"TIJLOSZ\".split(\"\").filter((piece) => !set.includes(piece)).join(\"\") : set;\r\n        count = count === \"!\" ? set.length : Number(count);\r\n        if(queue.length < count || set.length < count)return false;\r\n\r\n        for (let piece of queue.substring(0, count)) {\r\n            if (!set.includes(piece)) return false;\r\n            set = set.replace(piece, \"\");\r\n        }\r\n        queue = queue.substring(count, queue.length);\r\n    }\r\n\r\n    return !queue.length;\r\n}\r\n\r\nfunction checkModifiers(queue: string, pattern: string): boolean {\r\n    \r\n    \r\n    return false;\r\n}\r\n\r\n// export default function pieces(queue: string, pattern: string): boolean {\r\n//     console.log(`Queue: ${queue}, Set: ${pattern}`);\r\n//     var [pattern, modifiers] = pattern.split(\"{\");\r\n//     if (modifiers?.endsWith(\"}\"))\r\n//         modifiers = modifiers.slice(0, modifiers.length - 1);\r\n//     console.log(`Pattern: ${pattern}, Modifiers: ${modifiers}`);\r\n\r\n//     const queuePieces = queue.trim();\r\n//     return checkPieces(queuePieces, pattern);\r\n// }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}